
'''
MAVLink protocol implementation (auto-generated by mavgen.py)

Generated from: ../mavlink/message_definitions/common.xml

Note: this file has been auto-generated. DO NOT EDIT
'''

import struct

def x25crc(buf):
    '''x25 CRC - based on checksum.h from mavlink library'''
    accum = 0xffff
    for b in buf:
        tmp = ord(b) ^ (accum & 0xff)
        tmp = (tmp ^ (tmp<<4)) & 0xFF
        accum = (accum>>8) ^ (tmp<<8) ^ (tmp<<3) ^ (tmp>>4)
        accum = accum & 0xFFFF
    return accum

class MAVLink_header(object):
    '''MAVLink message header'''
    def __init__(self, msgId, mlen=0, seq=0, srcSystem=0, srcComponent=0):
        self.mlen = mlen
        self.seq = seq
        self.srcSystem = srcSystem
        self.srcComponent = srcComponent
        self.msgId = msgId

    def pack(self):
        return struct.pack('cBBBBB', 'U', self.mlen, self.seq,
                          self.srcSystem, self.srcComponent, self.msgId)

class MAVLink_message(object):
    '''base MAVLink message class'''
    def __init__(self, msgId):
        self._header     = MAVLink_header(msgId)
        self._payload    = None
        self._msgbuf     = None
        self._crc        = None
        self._fieldnames = []

    def msgbuf(self):
        return self._msgbuf

    def header(self):
        return self._header

    def payload(self):
        return self._payload

    def crc(self):
        return self._crc

    def fieldnames(self):
        return self._fieldnames

    def msgId(self):
        return self._header.msgId

    def __str__(self):
        ret = '{'
        for a in self._fieldnames:
            v = getattr(self, a)
            ret += '%s : %s, ' % (a, v)
        ret = ret[0:-2] + '}'
        return ret            

    def pack(self, mav, payload):
        self._payload = payload
        self._header  = MAVLink_header(self._header.msgId, len(payload), mav.seq,
                                       mav.srcSystem, mav.srcComponent)
        self._msgbuf = self._header.pack() + payload
        self._crc = x25crc(self._msgbuf[1:])
        self._msgbuf += struct.pack('<H', self._crc)
        return self._msgbuf

MAVLINK_MSG_ID_HEARTBEAT = 0
MAVLINK_MSG_ID_BOOT = 1
MAVLINK_MSG_ID_SYSTEM_TIME = 2
MAVLINK_MSG_ID_PING = 3
MAVLINK_MSG_ID_ACTION = 10
MAVLINK_MSG_ID_ACTION_ACK = 62
MAVLINK_MSG_ID_SET_MODE = 11
MAVLINK_MSG_ID_SET_NAV_MODE = 12
MAVLINK_MSG_ID_PARAM_REQUEST_READ = 20
MAVLINK_MSG_ID_PARAM_REQUEST_LIST = 21
MAVLINK_MSG_ID_PARAM_VALUE = 22
MAVLINK_MSG_ID_PARAM_SET = 23
MAVLINK_MSG_ID_RAW_IMU = 28
MAVLINK_MSG_ID_RAW_PRESSURE = 29
MAVLINK_MSG_ID_ATTITUDE = 30
MAVLINK_MSG_ID_LOCAL_POSITION = 31
MAVLINK_MSG_ID_GPS_RAW = 32
MAVLINK_MSG_ID_GPS_STATUS = 27
MAVLINK_MSG_ID_GLOBAL_POSITION = 33
MAVLINK_MSG_ID_SYS_STATUS = 34
MAVLINK_MSG_ID_RC_CHANNELS_RAW = 35
MAVLINK_MSG_ID_RC_CHANNELS_SCALED = 36
MAVLINK_MSG_ID_WAYPOINT = 39
MAVLINK_MSG_ID_WAYPOINT_REQUEST = 40
MAVLINK_MSG_ID_WAYPOINT_SET_CURRENT = 41
MAVLINK_MSG_ID_WAYPOINT_CURRENT = 42
MAVLINK_MSG_ID_WAYPOINT_REQUEST_LIST = 43
MAVLINK_MSG_ID_WAYPOINT_COUNT = 44
MAVLINK_MSG_ID_WAYPOINT_CLEAR_ALL = 45
MAVLINK_MSG_ID_WAYPOINT_REACHED = 46
MAVLINK_MSG_ID_WAYPOINT_ACK = 47
MAVLINK_MSG_ID_WAYPOINT_SET_GLOBAL_REFERENCE = 48
MAVLINK_MSG_ID_LOCAL_POSITION_SETPOINT_SET = 50
MAVLINK_MSG_ID_LOCAL_POSITION_SETPOINT = 51
MAVLINK_MSG_ID_ATTITUDE_CONTROLLER_OUTPUT = 60
MAVLINK_MSG_ID_POSITION_CONTROLLER_OUTPUT = 61
MAVLINK_MSG_ID_POSITION_TARGET = 63
MAVLINK_MSG_ID_STATE_CORRECTION = 64
MAVLINK_MSG_ID_SET_ALTITUDE = 65
MAVLINK_MSG_ID_REQUEST_DATA_STREAM = 66
MAVLINK_MSG_ID_REQUEST_DYNAMIC_GYRO_CALIBRATION = 67
MAVLINK_MSG_ID_REQUEST_STATIC_CALIBRATION = 68
MAVLINK_MSG_ID_MANUAL_CONTROL = 69
MAVLINK_MSG_ID_DEBUG_VECT = 70
MAVLINK_MSG_ID_GPS_LOCAL_ORIGIN_SET = 71
MAVLINK_MSG_ID_AIRSPEED = 72
MAVLINK_MSG_ID_GLOBAL_POSITION_INT = 73
MAVLINK_MSG_ID_NAMED_VALUE_FLOAT = 252
MAVLINK_MSG_ID_NAMED_VALUE_INT = 253
MAVLINK_MSG_ID_STATUSTEXT = 254
MAVLINK_MSG_ID_DEBUG = 255

class MAVLink_heartbeat_message(MAVLink_message):
	'''
	The heartbeat message shows that a system is present and responding.
	The type of the MAV and Autopilot hardware allow the receiving system
	to treat further messages from this system appropriate (e.g. by
	laying out the user interface based on the autopilot).
	'''
	def __init__(self, type, autopilot, mavlink_version):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_HEARTBEAT)
		self._fieldnames = ['type', 'autopilot', 'mavlink_version']
		self.type = type
		self.autopilot = autopilot
		self.mavlink_version = mavlink_version

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BBB', self.type, self.autopilot, self.mavlink_version))

class MAVLink_boot_message(MAVLink_message):
	'''
	The boot message indicates that a system is starting. The onboard
	software version allows to keep track of onboard soft/firmware
	revisions.
	'''
	def __init__(self, version):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_BOOT)
		self._fieldnames = ['version']
		self.version = version

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>I', self.version))

class MAVLink_system_time_message(MAVLink_message):
	'''
	The system time is the time of the master clock, typically the
	computer clock of the main onboard computer.
	'''
	def __init__(self, time_usec):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_SYSTEM_TIME)
		self._fieldnames = ['time_usec']
		self.time_usec = time_usec

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>Q', self.time_usec))

class MAVLink_ping_message(MAVLink_message):
	'''
	A ping message either requesting or responding to a ping. This allows
	to measure the system latencies, including serial port, radio modem
	and UDP connections.
	'''
	def __init__(self, seq, target_system, target_component, time):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_PING)
		self._fieldnames = ['seq', 'target_system', 'target_component', 'time']
		self.seq = seq
		self.target_system = target_system
		self.target_component = target_component
		self.time = time

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>IBBQ', self.seq, self.target_system, self.target_component, self.time))

class MAVLink_action_message(MAVLink_message):
	'''
	An action message allows to execute a certain onboard action. These
	include liftoff, land, storing parameters too EEPROM, shutddown, etc.
	The action ids are defined in ENUM MAV_ACTION in
	mavlink/include/mavlink_types.h
	'''
	def __init__(self, target, target_component, action):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_ACTION)
		self._fieldnames = ['target', 'target_component', 'action']
		self.target = target
		self.target_component = target_component
		self.action = action

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BBB', self.target, self.target_component, self.action))

class MAVLink_action_ack_message(MAVLink_message):
	'''
	This message acknowledges an action. IMPORTANT: The acknowledgement
	can be also negative, e.g. the MAV rejects a reset message because it
	is in-flight. The action ids are defined in ENUM MAV_ACTION in
	mavlink/include/mavlink_types.h
	'''
	def __init__(self, action, result):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_ACTION_ACK)
		self._fieldnames = ['action', 'result']
		self.action = action
		self.result = result

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BB', self.action, self.result))

class MAVLink_set_mode_message(MAVLink_message):
	'''
	Set the system mode, as defined by enum MAV_MODE in
	mavlink/include/mavlink_types.h. There is no target component id as
	the mode is by definition for the overall aircraft, not only for one
	component.
	'''
	def __init__(self, target, mode):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_SET_MODE)
		self._fieldnames = ['target', 'mode']
		self.target = target
		self.mode = mode

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BB', self.target, self.mode))

class MAVLink_set_nav_mode_message(MAVLink_message):
	'''
	Set the system navigation mode, as defined by enum MAV_NAV_MODE in
	mavlink/include/mavlink_types.h. The navigation mode applies to the
	whole aircraft and thus all components.
	'''
	def __init__(self, target, nav_mode):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_SET_NAV_MODE)
		self._fieldnames = ['target', 'nav_mode']
		self.target = target
		self.nav_mode = nav_mode

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BB', self.target, self.nav_mode))

class MAVLink_param_request_read_message(MAVLink_message):
	'''
	Request to read the onboard parameter with the param_id string id.
	Onboard parameters are stored as key[const char*] -> value[float].
	This allows to send a parameter to any other component (such as the
	GCS) without the need of previous knowledge of possible parameter
	names. Thus the same GCS can store different parameters for different
	autopilots. See also http://qgroundcontrol.org/parameter_interface
	for a full documentation of QGroundControl and IMU code.
	'''
	def __init__(self, target_system, target_component, param_id, param_index):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_PARAM_REQUEST_READ)
		self._fieldnames = ['target_system', 'target_component', 'param_id', 'param_index']
		self.target_system = target_system
		self.target_component = target_component
		self.param_id = param_id
		self.param_index = param_index

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BB15sH', self.target_system, self.target_component, self.param_id, self.param_index))

class MAVLink_param_request_list_message(MAVLink_message):
	'''
	Request all parameters of this component. After his request, all
	parameters are emitted.
	'''
	def __init__(self, target_system, target_component):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_PARAM_REQUEST_LIST)
		self._fieldnames = ['target_system', 'target_component']
		self.target_system = target_system
		self.target_component = target_component

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BB', self.target_system, self.target_component))

class MAVLink_param_value_message(MAVLink_message):
	'''
	Emit the value of a onboard parameter. The inclusion of param_count
	and param_index in the message allows the recipient to keep track of
	received parameters and allows him to re-request missing parameters
	after a loss or timeout.
	'''
	def __init__(self, param_id, param_value, param_count, param_index):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_PARAM_VALUE)
		self._fieldnames = ['param_id', 'param_value', 'param_count', 'param_index']
		self.param_id = param_id
		self.param_value = param_value
		self.param_count = param_count
		self.param_index = param_index

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>15sfHH', self.param_id, self.param_value, self.param_count, self.param_index))

class MAVLink_param_set_message(MAVLink_message):
	'''
	Set a parameter value TEMPORARILY to RAM. It will be reset to default
	on system reboot. Send the ACTION MAV_ACTION_STORAGE_WRITE to
	PERMANENTLY write the RAM contents to EEPROM. IMPORTANT: The
	receiving component should acknowledge the new parameter value by
	sending a param_value message to all communication partners. This
	will also ensure that multiple GCS all have an up-to-date list of all
	parameters. If the sending GCS did not receive a PARAM_VALUE message
	within its timeout time, it should re-send the PARAM_SET message.
	'''
	def __init__(self, target_system, target_component, param_id, param_value):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_PARAM_SET)
		self._fieldnames = ['target_system', 'target_component', 'param_id', 'param_value']
		self.target_system = target_system
		self.target_component = target_component
		self.param_id = param_id
		self.param_value = param_value

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BB15sf', self.target_system, self.target_component, self.param_id, self.param_value))

class MAVLink_raw_imu_message(MAVLink_message):
	'''
	The RAW IMU readings for the usual 9DOF sensor setup. This message
	should always contain the true raw values without any scaling to
	allow data capture and system debugging.
	'''
	def __init__(self, usec, xacc, yacc, zacc, xgyro, ygyro, zgyro, xmag, ymag, zmag):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_RAW_IMU)
		self._fieldnames = ['usec', 'xacc', 'yacc', 'zacc', 'xgyro', 'ygyro', 'zgyro', 'xmag', 'ymag', 'zmag']
		self.usec = usec
		self.xacc = xacc
		self.yacc = yacc
		self.zacc = zacc
		self.xgyro = xgyro
		self.ygyro = ygyro
		self.zgyro = zgyro
		self.xmag = xmag
		self.ymag = ymag
		self.zmag = zmag

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>Qhhhhhhhhh', self.usec, self.xacc, self.yacc, self.zacc, self.xgyro, self.ygyro, self.zgyro, self.xmag, self.ymag, self.zmag))

class MAVLink_raw_pressure_message(MAVLink_message):
	'''
	The RAW pressure readings for the typical setup of one absolute
	pressure and one differential pressure sensor. The sensor values
	should be the raw, unscaled ADC values.
	'''
	def __init__(self, usec, press_abs, press_diff1, press_diff2, temperature):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_RAW_PRESSURE)
		self._fieldnames = ['usec', 'press_abs', 'press_diff1', 'press_diff2', 'temperature']
		self.usec = usec
		self.press_abs = press_abs
		self.press_diff1 = press_diff1
		self.press_diff2 = press_diff2
		self.temperature = temperature

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>QHhhh', self.usec, self.press_abs, self.press_diff1, self.press_diff2, self.temperature))

class MAVLink_attitude_message(MAVLink_message):
	'''
	The attitude in the aeronautical frame (right-handed, Z-down,
	X-front, Y-right).
	'''
	def __init__(self, usec, roll, pitch, yaw, rollspeed, pitchspeed, yawspeed):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_ATTITUDE)
		self._fieldnames = ['usec', 'roll', 'pitch', 'yaw', 'rollspeed', 'pitchspeed', 'yawspeed']
		self.usec = usec
		self.roll = roll
		self.pitch = pitch
		self.yaw = yaw
		self.rollspeed = rollspeed
		self.pitchspeed = pitchspeed
		self.yawspeed = yawspeed

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>Qffffff', self.usec, self.roll, self.pitch, self.yaw, self.rollspeed, self.pitchspeed, self.yawspeed))

class MAVLink_local_position_message(MAVLink_message):
	'''
	The filtered local position (e.g. fused computer vision and
	accelerometers).
	'''
	def __init__(self, usec, x, y, z, vx, vy, vz):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_LOCAL_POSITION)
		self._fieldnames = ['usec', 'x', 'y', 'z', 'vx', 'vy', 'vz']
		self.usec = usec
		self.x = x
		self.y = y
		self.z = z
		self.vx = vx
		self.vy = vy
		self.vz = vz

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>Qffffff', self.usec, self.x, self.y, self.z, self.vx, self.vy, self.vz))

class MAVLink_gps_raw_message(MAVLink_message):
	'''
	The global position, as returned by the Global Positioning System
	(GPS). This is NOT the global position estimate of the sytem, but
	rather a RAW sensor value. See message GLOBAL_POSITION for the global
	position estimate.
	'''
	def __init__(self, usec, fix_type, lat, lon, alt, eph, epv, v, hdg):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_GPS_RAW)
		self._fieldnames = ['usec', 'fix_type', 'lat', 'lon', 'alt', 'eph', 'epv', 'v', 'hdg']
		self.usec = usec
		self.fix_type = fix_type
		self.lat = lat
		self.lon = lon
		self.alt = alt
		self.eph = eph
		self.epv = epv
		self.v = v
		self.hdg = hdg

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>QBfffffff', self.usec, self.fix_type, self.lat, self.lon, self.alt, self.eph, self.epv, self.v, self.hdg))

class MAVLink_gps_status_message(MAVLink_message):
	'''
	The global position, as returned by the Global Positioning System
	(GPS). This is NOT the global position estimate of the sytem, but
	rather a RAW sensor value. See message GLOBAL_POSITION for the global
	position estimate. This message can contain information for up to 20
	satellites.
	'''
	def __init__(self, satellites_visible, satellite_prn, satellite_used, satellite_elevation, satellite_azimuth, satellite_snr):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_GPS_STATUS)
		self._fieldnames = ['satellites_visible', 'satellite_prn', 'satellite_used', 'satellite_elevation', 'satellite_azimuth', 'satellite_snr']
		self.satellites_visible = satellites_visible
		self.satellite_prn = satellite_prn
		self.satellite_used = satellite_used
		self.satellite_elevation = satellite_elevation
		self.satellite_azimuth = satellite_azimuth
		self.satellite_snr = satellite_snr

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>B20s20s20s20s20s', self.satellites_visible, self.satellite_prn, self.satellite_used, self.satellite_elevation, self.satellite_azimuth, self.satellite_snr))

class MAVLink_global_position_message(MAVLink_message):
	'''
	The filtered global position (e.g. fused GPS and accelerometers).
	'''
	def __init__(self, usec, lat, lon, alt, vx, vy, vz):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_GLOBAL_POSITION)
		self._fieldnames = ['usec', 'lat', 'lon', 'alt', 'vx', 'vy', 'vz']
		self.usec = usec
		self.lat = lat
		self.lon = lon
		self.alt = alt
		self.vx = vx
		self.vy = vy
		self.vz = vz

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>Qffffff', self.usec, self.lat, self.lon, self.alt, self.vx, self.vy, self.vz))

class MAVLink_sys_status_message(MAVLink_message):
	'''
	The general system state. If the system is following the MAVLink
	standard, the system state is mainly defined by three orthogonal
	states/modes: The system mode, which is either LOCKED (motors shut
	down and locked), MANUAL (system under RC control), GUIDED (system
	with autonomous position control, position setpoint controlled
	manually) or AUTO (system guided by path/waypoint planner). The
	NAV_MODE defined the current flight state: LIFTOFF (often an open-
	loop maneuver), LANDING, WAYPOINTS or VECTOR. This represents the
	internal navigation state machine. The system status shows wether the
	system is currently active or not and if an emergency occured. During
	the CRITICAL and EMERGENCY states the MAV is still considered to be
	active, but should start emergency procedures autonomously. After a
	failure occured it should first move from active to critical to allow
	manual intervention and then move to emergency after a certain
	timeout.
	'''
	def __init__(self, mode, nav_mode, status, load, vbat, motor_block, packet_drop):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_SYS_STATUS)
		self._fieldnames = ['mode', 'nav_mode', 'status', 'load', 'vbat', 'motor_block', 'packet_drop']
		self.mode = mode
		self.nav_mode = nav_mode
		self.status = status
		self.load = load
		self.vbat = vbat
		self.motor_block = motor_block
		self.packet_drop = packet_drop

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BBBHHBH', self.mode, self.nav_mode, self.status, self.load, self.vbat, self.motor_block, self.packet_drop))

class MAVLink_rc_channels_raw_message(MAVLink_message):
	'''
	The RAW values of the RC channels received. The standard PPM
	modulation is as follows: 1000 microseconds: 0%, 2000 microseconds:
	100%. Individual receivers/transmitters might violate this
	specification.
	'''
	def __init__(self, chan1_raw, chan2_raw, chan3_raw, chan4_raw, chan5_raw, chan6_raw, chan7_raw, chan8_raw, rssi):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_RC_CHANNELS_RAW)
		self._fieldnames = ['chan1_raw', 'chan2_raw', 'chan3_raw', 'chan4_raw', 'chan5_raw', 'chan6_raw', 'chan7_raw', 'chan8_raw', 'rssi']
		self.chan1_raw = chan1_raw
		self.chan2_raw = chan2_raw
		self.chan3_raw = chan3_raw
		self.chan4_raw = chan4_raw
		self.chan5_raw = chan5_raw
		self.chan6_raw = chan6_raw
		self.chan7_raw = chan7_raw
		self.chan8_raw = chan8_raw
		self.rssi = rssi

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>HHHHHHHHB', self.chan1_raw, self.chan2_raw, self.chan3_raw, self.chan4_raw, self.chan5_raw, self.chan6_raw, self.chan7_raw, self.chan8_raw, self.rssi))

class MAVLink_rc_channels_scaled_message(MAVLink_message):
	'''
	The scaled values of the RC channels received. (-100%) -10000, (0%)
	0, (100%) 10000
	'''
	def __init__(self, chan1_scaled, chan2_scaled, chan3_scaled, chan4_scaled, chan5_scaled, chan6_scaled, chan7_scaled, chan8_scaled, rssi):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_RC_CHANNELS_SCALED)
		self._fieldnames = ['chan1_scaled', 'chan2_scaled', 'chan3_scaled', 'chan4_scaled', 'chan5_scaled', 'chan6_scaled', 'chan7_scaled', 'chan8_scaled', 'rssi']
		self.chan1_scaled = chan1_scaled
		self.chan2_scaled = chan2_scaled
		self.chan3_scaled = chan3_scaled
		self.chan4_scaled = chan4_scaled
		self.chan5_scaled = chan5_scaled
		self.chan6_scaled = chan6_scaled
		self.chan7_scaled = chan7_scaled
		self.chan8_scaled = chan8_scaled
		self.rssi = rssi

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>hhhhhhhhB', self.chan1_scaled, self.chan2_scaled, self.chan3_scaled, self.chan4_scaled, self.chan5_scaled, self.chan6_scaled, self.chan7_scaled, self.chan8_scaled, self.rssi))

class MAVLink_waypoint_message(MAVLink_message):
	'''
	Message encoding a waypoint. This message is emitted to announce
	the presence of a waypoint. It cannot be used to set a waypoint, use
	WAYPOINT_SET for this purpose. The waypoint can be either in x, y, z
	meters (type: LOCAL) or x:lat, y:lon. The global and body frame are
	related as: positive Z-down, positive X(front looking north, positive
	Y(body:right) looking east. Therefore y encodes in global mode the
	latitude, whereas x encodes the longitude and z the GPS altitude
	(WGS84).
	'''
	def __init__(self, target_system, target_component, seq, frame, action, orbit, orbit_direction, param1, param2, current, x, y, z, yaw, autocontinue):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_WAYPOINT)
		self._fieldnames = ['target_system', 'target_component', 'seq', 'frame', 'action', 'orbit', 'orbit_direction', 'param1', 'param2', 'current', 'x', 'y', 'z', 'yaw', 'autocontinue']
		self.target_system = target_system
		self.target_component = target_component
		self.seq = seq
		self.frame = frame
		self.action = action
		self.orbit = orbit
		self.orbit_direction = orbit_direction
		self.param1 = param1
		self.param2 = param2
		self.current = current
		self.x = x
		self.y = y
		self.z = z
		self.yaw = yaw
		self.autocontinue = autocontinue

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BBHBBfBffBffffB', self.target_system, self.target_component, self.seq, self.frame, self.action, self.orbit, self.orbit_direction, self.param1, self.param2, self.current, self.x, self.y, self.z, self.yaw, self.autocontinue))

class MAVLink_waypoint_request_message(MAVLink_message):
	'''
	Request the information of the waypoint with the sequence number seq.
	The response of the system to this message should be a WAYPOINT
	message.
	'''
	def __init__(self, target_system, target_component, seq):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_WAYPOINT_REQUEST)
		self._fieldnames = ['target_system', 'target_component', 'seq']
		self.target_system = target_system
		self.target_component = target_component
		self.seq = seq

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BBH', self.target_system, self.target_component, self.seq))

class MAVLink_waypoint_set_current_message(MAVLink_message):
	'''
	Set the waypoint with sequence number seq as current waypoint. This
	means that the MAV will continue to this waypoint on the shortest
	path (not following the waypoints in-between).
	'''
	def __init__(self, target_system, target_component, seq):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_WAYPOINT_SET_CURRENT)
		self._fieldnames = ['target_system', 'target_component', 'seq']
		self.target_system = target_system
		self.target_component = target_component
		self.seq = seq

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BBH', self.target_system, self.target_component, self.seq))

class MAVLink_waypoint_current_message(MAVLink_message):
	'''
	Message that announces the sequence number of the current active
	waypoint. The MAV will fly towards this waypoint.
	'''
	def __init__(self, seq):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_WAYPOINT_CURRENT)
		self._fieldnames = ['seq']
		self.seq = seq

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>H', self.seq))

class MAVLink_waypoint_request_list_message(MAVLink_message):
	'''
	Request the overall list of waypoints from the system/component.
	'''
	def __init__(self, target_system, target_component):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_WAYPOINT_REQUEST_LIST)
		self._fieldnames = ['target_system', 'target_component']
		self.target_system = target_system
		self.target_component = target_component

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BB', self.target_system, self.target_component))

class MAVLink_waypoint_count_message(MAVLink_message):
	'''
	This message is emitted as response to WAYPOINT_REQUEST_LIST by the
	MAV. The GCS can then request the individual waypoints based on the
	knowledge of the total number of waypoints.
	'''
	def __init__(self, target_system, target_component, count):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_WAYPOINT_COUNT)
		self._fieldnames = ['target_system', 'target_component', 'count']
		self.target_system = target_system
		self.target_component = target_component
		self.count = count

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BBH', self.target_system, self.target_component, self.count))

class MAVLink_waypoint_clear_all_message(MAVLink_message):
	'''
	Delete all waypoints at once.
	'''
	def __init__(self, target_system, target_component):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_WAYPOINT_CLEAR_ALL)
		self._fieldnames = ['target_system', 'target_component']
		self.target_system = target_system
		self.target_component = target_component

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BB', self.target_system, self.target_component))

class MAVLink_waypoint_reached_message(MAVLink_message):
	'''
	A certain waypoint has been reached. The system will either hold this
	position (or circle on the orbit) or (if the autocontinue on the WP
	was set) continue to the next waypoint.
	'''
	def __init__(self, seq):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_WAYPOINT_REACHED)
		self._fieldnames = ['seq']
		self.seq = seq

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>H', self.seq))

class MAVLink_waypoint_ack_message(MAVLink_message):
	'''
	Ack message during waypoint handling. The type field states if this
	message is a positive ack (type=0) or if an error happened (type=non-
	zero).
	'''
	def __init__(self, target_system, target_component, type):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_WAYPOINT_ACK)
		self._fieldnames = ['target_system', 'target_component', 'type']
		self.target_system = target_system
		self.target_component = target_component
		self.type = type

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BBB', self.target_system, self.target_component, self.type))

class MAVLink_waypoint_set_global_reference_message(MAVLink_message):
	'''
	As local waypoints exist, the global waypoint reference allows to
	transform between the local coordinate frame and the global (GPS)
	coordinate frame. This can be necessary when e.g. in- and outdoor
	settings are connected and the MAV should move from in- to outdoor.
	'''
	def __init__(self, target_system, target_component, global_x, global_y, global_z, global_yaw, local_x, local_y, local_z, local_yaw):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_WAYPOINT_SET_GLOBAL_REFERENCE)
		self._fieldnames = ['target_system', 'target_component', 'global_x', 'global_y', 'global_z', 'global_yaw', 'local_x', 'local_y', 'local_z', 'local_yaw']
		self.target_system = target_system
		self.target_component = target_component
		self.global_x = global_x
		self.global_y = global_y
		self.global_z = global_z
		self.global_yaw = global_yaw
		self.local_x = local_x
		self.local_y = local_y
		self.local_z = local_z
		self.local_yaw = local_yaw

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BBffffffff', self.target_system, self.target_component, self.global_x, self.global_y, self.global_z, self.global_yaw, self.local_x, self.local_y, self.local_z, self.local_yaw))

class MAVLink_local_position_setpoint_set_message(MAVLink_message):
	'''
	Set the setpoint for a local position controller. This is the
	position in local coordinates the MAV should fly to. This message is
	sent by the path/waypoint planner to the onboard position controller.
	As some MAVs have a degree of freedom in yaw (e.g. all
	helicopters/quadrotors), the desired yaw angle is part of the
	message.
	'''
	def __init__(self, target_system, target_component, x, y, z, yaw):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_LOCAL_POSITION_SETPOINT_SET)
		self._fieldnames = ['target_system', 'target_component', 'x', 'y', 'z', 'yaw']
		self.target_system = target_system
		self.target_component = target_component
		self.x = x
		self.y = y
		self.z = z
		self.yaw = yaw

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BBffff', self.target_system, self.target_component, self.x, self.y, self.z, self.yaw))

class MAVLink_local_position_setpoint_message(MAVLink_message):
	'''
	Transmit the current local setpoint of the controller to other MAVs
	(collision avoidance) and to the GCS.
	'''
	def __init__(self, x, y, z, yaw):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_LOCAL_POSITION_SETPOINT)
		self._fieldnames = ['x', 'y', 'z', 'yaw']
		self.x = x
		self.y = y
		self.z = z
		self.yaw = yaw

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>ffff', self.x, self.y, self.z, self.yaw))

class MAVLink_attitude_controller_output_message(MAVLink_message):
	'''
	The output of the attitude controller. This output is the control
	response the controller currently generates and the attitude the MAV
	would take if it is under control of the attitude controller. The
	primary use of this message is to check the response and signs of the
	controller before the actual flight.
	'''
	def __init__(self, enabled, roll, pitch, yaw, thrust):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_ATTITUDE_CONTROLLER_OUTPUT)
		self._fieldnames = ['enabled', 'roll', 'pitch', 'yaw', 'thrust']
		self.enabled = enabled
		self.roll = roll
		self.pitch = pitch
		self.yaw = yaw
		self.thrust = thrust

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>Bbbbb', self.enabled, self.roll, self.pitch, self.yaw, self.thrust))

class MAVLink_position_controller_output_message(MAVLink_message):
	'''
	The output of the position controller. The primary use of this
	message is to check the response and signs of the controller before
	the actual flight.
	'''
	def __init__(self, enabled, x, y, z, yaw):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_POSITION_CONTROLLER_OUTPUT)
		self._fieldnames = ['enabled', 'x', 'y', 'z', 'yaw']
		self.enabled = enabled
		self.x = x
		self.y = y
		self.z = z
		self.yaw = yaw

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>Bbbbb', self.enabled, self.x, self.y, self.z, self.yaw))

class MAVLink_position_target_message(MAVLink_message):
	'''
	The goal position of the system. This position is the input to any
	navigation or path planning algorithm and does NOT represent the
	current controller setpoint.
	'''
	def __init__(self, x, y, z, yaw):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_POSITION_TARGET)
		self._fieldnames = ['x', 'y', 'z', 'yaw']
		self.x = x
		self.y = y
		self.z = z
		self.yaw = yaw

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>ffff', self.x, self.y, self.z, self.yaw))

class MAVLink_state_correction_message(MAVLink_message):
	'''
	Corrects the systems state by adding an error correction term to the
	position and velocity, and by rotating the attitude by a correction
	angle.
	'''
	def __init__(self, xErr, yErr, zErr, rollErr, pitchErr, yawErr, vxErr, vyErr, vzErr):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_STATE_CORRECTION)
		self._fieldnames = ['xErr', 'yErr', 'zErr', 'rollErr', 'pitchErr', 'yawErr', 'vxErr', 'vyErr', 'vzErr']
		self.xErr = xErr
		self.yErr = yErr
		self.zErr = zErr
		self.rollErr = rollErr
		self.pitchErr = pitchErr
		self.yawErr = yawErr
		self.vxErr = vxErr
		self.vyErr = vyErr
		self.vzErr = vzErr

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>fffffffff', self.xErr, self.yErr, self.zErr, self.rollErr, self.pitchErr, self.yawErr, self.vxErr, self.vyErr, self.vzErr))

class MAVLink_set_altitude_message(MAVLink_message):
	'''

	'''
	def __init__(self, target, mode):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_SET_ALTITUDE)
		self._fieldnames = ['target', 'mode']
		self.target = target
		self.mode = mode

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BI', self.target, self.mode))

class MAVLink_request_data_stream_message(MAVLink_message):
	'''

	'''
	def __init__(self, target_system, target_component, req_stream_id, req_message_rate, start_stop):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_REQUEST_DATA_STREAM)
		self._fieldnames = ['target_system', 'target_component', 'req_stream_id', 'req_message_rate', 'start_stop']
		self.target_system = target_system
		self.target_component = target_component
		self.req_stream_id = req_stream_id
		self.req_message_rate = req_message_rate
		self.start_stop = start_stop

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BBBHB', self.target_system, self.target_component, self.req_stream_id, self.req_message_rate, self.start_stop))

class MAVLink_request_dynamic_gyro_calibration_message(MAVLink_message):
	'''

	'''
	def __init__(self, target_system, target_component, mode, axis, time):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_REQUEST_DYNAMIC_GYRO_CALIBRATION)
		self._fieldnames = ['target_system', 'target_component', 'mode', 'axis', 'time']
		self.target_system = target_system
		self.target_component = target_component
		self.mode = mode
		self.axis = axis
		self.time = time

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BBfBH', self.target_system, self.target_component, self.mode, self.axis, self.time))

class MAVLink_request_static_calibration_message(MAVLink_message):
	'''

	'''
	def __init__(self, target_system, target_component, time):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_REQUEST_STATIC_CALIBRATION)
		self._fieldnames = ['target_system', 'target_component', 'time']
		self.target_system = target_system
		self.target_component = target_component
		self.time = time

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BBH', self.target_system, self.target_component, self.time))

class MAVLink_manual_control_message(MAVLink_message):
	'''

	'''
	def __init__(self, target, roll, pitch, yaw, thrust, roll_manual, pitch_manual, yaw_manual, thrust_manual):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_MANUAL_CONTROL)
		self._fieldnames = ['target', 'roll', 'pitch', 'yaw', 'thrust', 'roll_manual', 'pitch_manual', 'yaw_manual', 'thrust_manual']
		self.target = target
		self.roll = roll
		self.pitch = pitch
		self.yaw = yaw
		self.thrust = thrust
		self.roll_manual = roll_manual
		self.pitch_manual = pitch_manual
		self.yaw_manual = yaw_manual
		self.thrust_manual = thrust_manual

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>BffffBBBB', self.target, self.roll, self.pitch, self.yaw, self.thrust, self.roll_manual, self.pitch_manual, self.yaw_manual, self.thrust_manual))

class MAVLink_debug_vect_message(MAVLink_message):
	'''

	'''
	def __init__(self, name, usec, x, y, z):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_DEBUG_VECT)
		self._fieldnames = ['name', 'usec', 'x', 'y', 'z']
		self.name = name
		self.usec = usec
		self.x = x
		self.y = y
		self.z = z

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>10sQfff', self.name, self.usec, self.x, self.y, self.z))

class MAVLink_gps_local_origin_set_message(MAVLink_message):
	'''
	Once the MAV sets a new GPS-Local correspondence, this message
	announces
	'''
	def __init__(self, latitude, longitude, altitude):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_GPS_LOCAL_ORIGIN_SET)
		self._fieldnames = ['latitude', 'longitude', 'altitude']
		self.latitude = latitude
		self.longitude = longitude
		self.altitude = altitude

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>iii', self.latitude, self.longitude, self.altitude))

class MAVLink_airspeed_message(MAVLink_message):
	'''
	The calculated airspeed
	'''
	def __init__(self, airspeed):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_AIRSPEED)
		self._fieldnames = ['airspeed']
		self.airspeed = airspeed

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>f', self.airspeed))

class MAVLink_global_position_int_message(MAVLink_message):
	'''
	The filtered global position (e.g. fused GPS and accelerometers). The
	position is in GPS-frame (right-handed, Z-up)
	'''
	def __init__(self, lat, lon, alt, vx, vy, vz):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_GLOBAL_POSITION_INT)
		self._fieldnames = ['lat', 'lon', 'alt', 'vx', 'vy', 'vz']
		self.lat = lat
		self.lon = lon
		self.alt = alt
		self.vx = vx
		self.vy = vy
		self.vz = vz

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>iiihhh', self.lat, self.lon, self.alt, self.vx, self.vy, self.vz))

class MAVLink_named_value_float_message(MAVLink_message):
	'''
	Send a key-value pair as float. The use of this message is
	discouraged for normal packets, but a quite efficient way for testing
	new messages and getting experimental debug output.
	'''
	def __init__(self, name, value):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_NAMED_VALUE_FLOAT)
		self._fieldnames = ['name', 'value']
		self.name = name
		self.value = value

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>10sf', self.name, self.value))

class MAVLink_named_value_int_message(MAVLink_message):
	'''
	Send a key-value pair as integer. The use of this message is
	discouraged for normal packets, but a quite efficient way for testing
	new messages and getting experimental debug output.
	'''
	def __init__(self, name, value):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_NAMED_VALUE_INT)
		self._fieldnames = ['name', 'value']
		self.name = name
		self.value = value

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>10si', self.name, self.value))

class MAVLink_statustext_message(MAVLink_message):
	'''
	Status text message. These messages are printed in yellow in the COMM
	console of QGroundControl. WARNING: They consume quite some
	bandwidth, so use only for important status and error messages. If
	implemented wisely, these messages are buffered on the MCU and sent
	only at a limited rate (e.g. 10 Hz).
	'''
	def __init__(self, severity, text):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_STATUSTEXT)
		self._fieldnames = ['severity', 'text']
		self.severity = severity
		self.text = text

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>B50s', self.severity, self.text))

class MAVLink_debug_message(MAVLink_message):
	'''
	Send a debug value. The index is used to discriminate between values.
	These values show up in the plot of QGroundControl as DEBUG N.
	'''
	def __init__(self, ind, value):
		MAVLink_message.__init__(self, MAVLINK_MSG_ID_DEBUG)
		self._fieldnames = ['ind', 'value']
		self.ind = ind
		self.value = value

	def pack(self, mav):
		return MAVLink_message.pack(self, mav, struct.pack('>Bf', self.ind, self.value))

class MAVError(Exception):
	def __init__(self, msg):
            Exception.__init__(self, msg)
            
class MAVLink(object):
	def __init__(self, file, srcSystem=0, srcComponent=0):
		self.seq = 0
		self.file = file
		self.srcSystem = srcSystem
		self.srcComponent = srcComponent

	def send(self, mavmsg):
		buf = mavmsg.pack(self)
		self.file.write(buf)
		self.seq += 1

	def decode(self, msgbuf):
		magic, mlen, seq, srcSystem, srcComponent, msgId = struct.unpack('cBBBBB', msgbuf[:6])
                if magic != 'U':
                    raise MAVError('invalid MAVLink prefix')
                if mlen != len(msgbuf)-8:
                    raise MAVError('invalid MAVLink message length')
                crc, = struct.unpack('<H', msgbuf[-2:])
                crc2 = x25crc(msgbuf[1:-2])
                if crc != crc2:
                    raise MAVError('invalid MAVLink CRC 0x%04x should be 0x%04x' % (crc, crc2))
                
		if msgId == MAVLINK_MSG_ID_HEARTBEAT:
			type, autopilot, mavlink_version = struct.unpack('>BBB', msgbuf[6:-2])
			return MAVLink_heartbeat_message(type, autopilot, mavlink_version)
		if msgId == MAVLINK_MSG_ID_BOOT:
			version = struct.unpack('>I', msgbuf[6:-2])
			return MAVLink_boot_message(version)
		if msgId == MAVLINK_MSG_ID_SYSTEM_TIME:
			time_usec = struct.unpack('>Q', msgbuf[6:-2])
			return MAVLink_system_time_message(time_usec)
		if msgId == MAVLINK_MSG_ID_PING:
			seq, target_system, target_component, time = struct.unpack('>IBBQ', msgbuf[6:-2])
			return MAVLink_ping_message(seq, target_system, target_component, time)
		if msgId == MAVLINK_MSG_ID_ACTION:
			target, target_component, action = struct.unpack('>BBB', msgbuf[6:-2])
			return MAVLink_action_message(target, target_component, action)
		if msgId == MAVLINK_MSG_ID_ACTION_ACK:
			action, result = struct.unpack('>BB', msgbuf[6:-2])
			return MAVLink_action_ack_message(action, result)
		if msgId == MAVLINK_MSG_ID_SET_MODE:
			target, mode = struct.unpack('>BB', msgbuf[6:-2])
			return MAVLink_set_mode_message(target, mode)
		if msgId == MAVLINK_MSG_ID_SET_NAV_MODE:
			target, nav_mode = struct.unpack('>BB', msgbuf[6:-2])
			return MAVLink_set_nav_mode_message(target, nav_mode)
		if msgId == MAVLINK_MSG_ID_PARAM_REQUEST_READ:
			target_system, target_component, param_id, param_index = struct.unpack('>BB15sH', msgbuf[6:-2])
			return MAVLink_param_request_read_message(target_system, target_component, param_id, param_index)
		if msgId == MAVLINK_MSG_ID_PARAM_REQUEST_LIST:
			target_system, target_component = struct.unpack('>BB', msgbuf[6:-2])
			return MAVLink_param_request_list_message(target_system, target_component)
		if msgId == MAVLINK_MSG_ID_PARAM_VALUE:
			param_id, param_value, param_count, param_index = struct.unpack('>15sfHH', msgbuf[6:-2])
			return MAVLink_param_value_message(param_id, param_value, param_count, param_index)
		if msgId == MAVLINK_MSG_ID_PARAM_SET:
			target_system, target_component, param_id, param_value = struct.unpack('>BB15sf', msgbuf[6:-2])
			return MAVLink_param_set_message(target_system, target_component, param_id, param_value)
		if msgId == MAVLINK_MSG_ID_RAW_IMU:
			usec, xacc, yacc, zacc, xgyro, ygyro, zgyro, xmag, ymag, zmag = struct.unpack('>Qhhhhhhhhh', msgbuf[6:-2])
			return MAVLink_raw_imu_message(usec, xacc, yacc, zacc, xgyro, ygyro, zgyro, xmag, ymag, zmag)
		if msgId == MAVLINK_MSG_ID_RAW_PRESSURE:
			usec, press_abs, press_diff1, press_diff2, temperature = struct.unpack('>QHhhh', msgbuf[6:-2])
			return MAVLink_raw_pressure_message(usec, press_abs, press_diff1, press_diff2, temperature)
		if msgId == MAVLINK_MSG_ID_ATTITUDE:
			usec, roll, pitch, yaw, rollspeed, pitchspeed, yawspeed = struct.unpack('>Qffffff', msgbuf[6:-2])
			return MAVLink_attitude_message(usec, roll, pitch, yaw, rollspeed, pitchspeed, yawspeed)
		if msgId == MAVLINK_MSG_ID_LOCAL_POSITION:
			usec, x, y, z, vx, vy, vz = struct.unpack('>Qffffff', msgbuf[6:-2])
			return MAVLink_local_position_message(usec, x, y, z, vx, vy, vz)
		if msgId == MAVLINK_MSG_ID_GPS_RAW:
			usec, fix_type, lat, lon, alt, eph, epv, v, hdg = struct.unpack('>QBfffffff', msgbuf[6:-2])
			return MAVLink_gps_raw_message(usec, fix_type, lat, lon, alt, eph, epv, v, hdg)
		if msgId == MAVLINK_MSG_ID_GPS_STATUS:
			satellites_visible, satellite_prn, satellite_used, satellite_elevation, satellite_azimuth, satellite_snr = struct.unpack('>B20s20s20s20s20s', msgbuf[6:-2])
			return MAVLink_gps_status_message(satellites_visible, satellite_prn, satellite_used, satellite_elevation, satellite_azimuth, satellite_snr)
		if msgId == MAVLINK_MSG_ID_GLOBAL_POSITION:
			usec, lat, lon, alt, vx, vy, vz = struct.unpack('>Qffffff', msgbuf[6:-2])
			return MAVLink_global_position_message(usec, lat, lon, alt, vx, vy, vz)
		if msgId == MAVLINK_MSG_ID_SYS_STATUS:
			mode, nav_mode, status, load, vbat, motor_block, packet_drop = struct.unpack('>BBBHHBH', msgbuf[6:-2])
			return MAVLink_sys_status_message(mode, nav_mode, status, load, vbat, motor_block, packet_drop)
		if msgId == MAVLINK_MSG_ID_RC_CHANNELS_RAW:
			chan1_raw, chan2_raw, chan3_raw, chan4_raw, chan5_raw, chan6_raw, chan7_raw, chan8_raw, rssi = struct.unpack('>HHHHHHHHB', msgbuf[6:-2])
			return MAVLink_rc_channels_raw_message(chan1_raw, chan2_raw, chan3_raw, chan4_raw, chan5_raw, chan6_raw, chan7_raw, chan8_raw, rssi)
		if msgId == MAVLINK_MSG_ID_RC_CHANNELS_SCALED:
			chan1_scaled, chan2_scaled, chan3_scaled, chan4_scaled, chan5_scaled, chan6_scaled, chan7_scaled, chan8_scaled, rssi = struct.unpack('>hhhhhhhhB', msgbuf[6:-2])
			return MAVLink_rc_channels_scaled_message(chan1_scaled, chan2_scaled, chan3_scaled, chan4_scaled, chan5_scaled, chan6_scaled, chan7_scaled, chan8_scaled, rssi)
		if msgId == MAVLINK_MSG_ID_WAYPOINT:
			target_system, target_component, seq, frame, action, orbit, orbit_direction, param1, param2, current, x, y, z, yaw, autocontinue = struct.unpack('>BBHBBfBffBffffB', msgbuf[6:-2])
			return MAVLink_waypoint_message(target_system, target_component, seq, frame, action, orbit, orbit_direction, param1, param2, current, x, y, z, yaw, autocontinue)
		if msgId == MAVLINK_MSG_ID_WAYPOINT_REQUEST:
			target_system, target_component, seq = struct.unpack('>BBH', msgbuf[6:-2])
			return MAVLink_waypoint_request_message(target_system, target_component, seq)
		if msgId == MAVLINK_MSG_ID_WAYPOINT_SET_CURRENT:
			target_system, target_component, seq = struct.unpack('>BBH', msgbuf[6:-2])
			return MAVLink_waypoint_set_current_message(target_system, target_component, seq)
		if msgId == MAVLINK_MSG_ID_WAYPOINT_CURRENT:
			seq = struct.unpack('>H', msgbuf[6:-2])
			return MAVLink_waypoint_current_message(seq)
		if msgId == MAVLINK_MSG_ID_WAYPOINT_REQUEST_LIST:
			target_system, target_component = struct.unpack('>BB', msgbuf[6:-2])
			return MAVLink_waypoint_request_list_message(target_system, target_component)
		if msgId == MAVLINK_MSG_ID_WAYPOINT_COUNT:
			target_system, target_component, count = struct.unpack('>BBH', msgbuf[6:-2])
			return MAVLink_waypoint_count_message(target_system, target_component, count)
		if msgId == MAVLINK_MSG_ID_WAYPOINT_CLEAR_ALL:
			target_system, target_component = struct.unpack('>BB', msgbuf[6:-2])
			return MAVLink_waypoint_clear_all_message(target_system, target_component)
		if msgId == MAVLINK_MSG_ID_WAYPOINT_REACHED:
			seq = struct.unpack('>H', msgbuf[6:-2])
			return MAVLink_waypoint_reached_message(seq)
		if msgId == MAVLINK_MSG_ID_WAYPOINT_ACK:
			target_system, target_component, type = struct.unpack('>BBB', msgbuf[6:-2])
			return MAVLink_waypoint_ack_message(target_system, target_component, type)
		if msgId == MAVLINK_MSG_ID_WAYPOINT_SET_GLOBAL_REFERENCE:
			target_system, target_component, global_x, global_y, global_z, global_yaw, local_x, local_y, local_z, local_yaw = struct.unpack('>BBffffffff', msgbuf[6:-2])
			return MAVLink_waypoint_set_global_reference_message(target_system, target_component, global_x, global_y, global_z, global_yaw, local_x, local_y, local_z, local_yaw)
		if msgId == MAVLINK_MSG_ID_LOCAL_POSITION_SETPOINT_SET:
			target_system, target_component, x, y, z, yaw = struct.unpack('>BBffff', msgbuf[6:-2])
			return MAVLink_local_position_setpoint_set_message(target_system, target_component, x, y, z, yaw)
		if msgId == MAVLINK_MSG_ID_LOCAL_POSITION_SETPOINT:
			x, y, z, yaw = struct.unpack('>ffff', msgbuf[6:-2])
			return MAVLink_local_position_setpoint_message(x, y, z, yaw)
		if msgId == MAVLINK_MSG_ID_ATTITUDE_CONTROLLER_OUTPUT:
			enabled, roll, pitch, yaw, thrust = struct.unpack('>Bbbbb', msgbuf[6:-2])
			return MAVLink_attitude_controller_output_message(enabled, roll, pitch, yaw, thrust)
		if msgId == MAVLINK_MSG_ID_POSITION_CONTROLLER_OUTPUT:
			enabled, x, y, z, yaw = struct.unpack('>Bbbbb', msgbuf[6:-2])
			return MAVLink_position_controller_output_message(enabled, x, y, z, yaw)
		if msgId == MAVLINK_MSG_ID_POSITION_TARGET:
			x, y, z, yaw = struct.unpack('>ffff', msgbuf[6:-2])
			return MAVLink_position_target_message(x, y, z, yaw)
		if msgId == MAVLINK_MSG_ID_STATE_CORRECTION:
			xErr, yErr, zErr, rollErr, pitchErr, yawErr, vxErr, vyErr, vzErr = struct.unpack('>fffffffff', msgbuf[6:-2])
			return MAVLink_state_correction_message(xErr, yErr, zErr, rollErr, pitchErr, yawErr, vxErr, vyErr, vzErr)
		if msgId == MAVLINK_MSG_ID_SET_ALTITUDE:
			target, mode = struct.unpack('>BI', msgbuf[6:-2])
			return MAVLink_set_altitude_message(target, mode)
		if msgId == MAVLINK_MSG_ID_REQUEST_DATA_STREAM:
			target_system, target_component, req_stream_id, req_message_rate, start_stop = struct.unpack('>BBBHB', msgbuf[6:-2])
			return MAVLink_request_data_stream_message(target_system, target_component, req_stream_id, req_message_rate, start_stop)
		if msgId == MAVLINK_MSG_ID_REQUEST_DYNAMIC_GYRO_CALIBRATION:
			target_system, target_component, mode, axis, time = struct.unpack('>BBfBH', msgbuf[6:-2])
			return MAVLink_request_dynamic_gyro_calibration_message(target_system, target_component, mode, axis, time)
		if msgId == MAVLINK_MSG_ID_REQUEST_STATIC_CALIBRATION:
			target_system, target_component, time = struct.unpack('>BBH', msgbuf[6:-2])
			return MAVLink_request_static_calibration_message(target_system, target_component, time)
		if msgId == MAVLINK_MSG_ID_MANUAL_CONTROL:
			target, roll, pitch, yaw, thrust, roll_manual, pitch_manual, yaw_manual, thrust_manual = struct.unpack('>BffffBBBB', msgbuf[6:-2])
			return MAVLink_manual_control_message(target, roll, pitch, yaw, thrust, roll_manual, pitch_manual, yaw_manual, thrust_manual)
		if msgId == MAVLINK_MSG_ID_DEBUG_VECT:
			name, usec, x, y, z = struct.unpack('>10sQfff', msgbuf[6:-2])
			return MAVLink_debug_vect_message(name, usec, x, y, z)
		if msgId == MAVLINK_MSG_ID_GPS_LOCAL_ORIGIN_SET:
			latitude, longitude, altitude = struct.unpack('>iii', msgbuf[6:-2])
			return MAVLink_gps_local_origin_set_message(latitude, longitude, altitude)
		if msgId == MAVLINK_MSG_ID_AIRSPEED:
			airspeed = struct.unpack('>f', msgbuf[6:-2])
			return MAVLink_airspeed_message(airspeed)
		if msgId == MAVLINK_MSG_ID_GLOBAL_POSITION_INT:
			lat, lon, alt, vx, vy, vz = struct.unpack('>iiihhh', msgbuf[6:-2])
			return MAVLink_global_position_int_message(lat, lon, alt, vx, vy, vz)
		if msgId == MAVLINK_MSG_ID_NAMED_VALUE_FLOAT:
			name, value = struct.unpack('>10sf', msgbuf[6:-2])
			return MAVLink_named_value_float_message(name, value)
		if msgId == MAVLINK_MSG_ID_NAMED_VALUE_INT:
			name, value = struct.unpack('>10si', msgbuf[6:-2])
			return MAVLink_named_value_int_message(name, value)
		if msgId == MAVLINK_MSG_ID_STATUSTEXT:
			severity, text = struct.unpack('>B50s', msgbuf[6:-2])
			return MAVLink_statustext_message(severity, text)
		if msgId == MAVLINK_MSG_ID_DEBUG:
			ind, value = struct.unpack('>Bf', msgbuf[6:-2])
			return MAVLink_debug_message(ind, value)
		raise MAVError('Uknown MAVLink message ID %u' % msgId)


	def heartbeat_encode(self, type, autopilot, mavlink_version):
		'''
		The heartbeat message shows that a system is present and responding.
		The type of the MAV and Autopilot hardware allow the receiving
		system to treat further messages from this system appropriate (e.g.
		by laying out the user interface based on the autopilot).

		type              	: Type of the MAV (quadrotor, helicopter, etc., up to 15 types, defined in MAV_TYPE ENUM) (uint8_t)
		autopilot         	: Type of the Autopilot: 0: Generic, 1: PIXHAWK, 2: SLUGS, 3: Ardupilot (up to 15 types), defined in MAV_AUTOPILOT_TYPE ENUM (uint8_t)
		mavlink_version   	: MAVLink version (uint8_t_mavlink_version)

		'''
		msg = MAVLink_heartbeat_message(type, autopilot, mavlink_version)
		msg.pack(self)
                return msg

	def heartbeat_send(self, type, autopilot, mavlink_version):
		'''
		The heartbeat message shows that a system is present and responding.
		The type of the MAV and Autopilot hardware allow the receiving
		system to treat further messages from this system appropriate (e.g.
		by laying out the user interface based on the autopilot).

		type              	: Type of the MAV (quadrotor, helicopter, etc., up to 15 types, defined in MAV_TYPE ENUM) (uint8_t)
		autopilot         	: Type of the Autopilot: 0: Generic, 1: PIXHAWK, 2: SLUGS, 3: Ardupilot (up to 15 types), defined in MAV_AUTOPILOT_TYPE ENUM (uint8_t)
		mavlink_version   	: MAVLink version (uint8_t_mavlink_version)

		'''
		return self.send(self.heartbeat_encode(type, autopilot, mavlink_version))

	def boot_encode(self, version):
		'''
		The boot message indicates that a system is starting. The onboard
		software version allows to keep track of onboard soft/firmware
		revisions.

		version           	: The onboard software version (uint32_t)

		'''
		msg = MAVLink_boot_message(version)
		msg.pack(self)
                return msg

	def boot_send(self, version):
		'''
		The boot message indicates that a system is starting. The onboard
		software version allows to keep track of onboard soft/firmware
		revisions.

		version           	: The onboard software version (uint32_t)

		'''
		return self.send(self.boot_encode(version))

	def system_time_encode(self, time_usec):
		'''
		The system time is the time of the master clock, typically the
		computer clock of the main onboard computer.

		time_usec         	: Timestamp of the master clock in microseconds since UNIX epoch. (uint64_t)

		'''
		msg = MAVLink_system_time_message(time_usec)
		msg.pack(self)
                return msg

	def system_time_send(self, time_usec):
		'''
		The system time is the time of the master clock, typically the
		computer clock of the main onboard computer.

		time_usec         	: Timestamp of the master clock in microseconds since UNIX epoch. (uint64_t)

		'''
		return self.send(self.system_time_encode(time_usec))

	def ping_encode(self, seq, target_system, target_component, time):
		'''
		A ping message either requesting or responding to a ping. This allows
		to measure the system latencies, including serial port, radio modem
		and UDP connections.

		seq               	: PING sequence (uint32_t)
		target_system     	: 0: request ping from all receiving systems, if greater than 0: message is a ping response and number is the system id of the requesting system (uint8_t)
		target_component  	: 0: request ping from all receiving components, if greater than 0: message is a ping response and number is the system id of the requesting system (uint8_t)
		time              	: Unix timestamp in microseconds (uint64_t)

		'''
		msg = MAVLink_ping_message(seq, target_system, target_component, time)
		msg.pack(self)
                return msg

	def ping_send(self, seq, target_system, target_component, time):
		'''
		A ping message either requesting or responding to a ping. This allows
		to measure the system latencies, including serial port, radio modem
		and UDP connections.

		seq               	: PING sequence (uint32_t)
		target_system     	: 0: request ping from all receiving systems, if greater than 0: message is a ping response and number is the system id of the requesting system (uint8_t)
		target_component  	: 0: request ping from all receiving components, if greater than 0: message is a ping response and number is the system id of the requesting system (uint8_t)
		time              	: Unix timestamp in microseconds (uint64_t)

		'''
		return self.send(self.ping_encode(seq, target_system, target_component, time))

	def action_encode(self, target, target_component, action):
		'''
		An action message allows to execute a certain onboard action. These
		include liftoff, land, storing parameters too EEPROM, shutddown,
		etc. The action ids are defined in ENUM MAV_ACTION in
		mavlink/include/mavlink_types.h

		target            	: The system executing the action (uint8_t)
		target_component  	: The component executing the action (uint8_t)
		action            	: The action id (uint8_t)

		'''
		msg = MAVLink_action_message(target, target_component, action)
		msg.pack(self)
                return msg

	def action_send(self, target, target_component, action):
		'''
		An action message allows to execute a certain onboard action. These
		include liftoff, land, storing parameters too EEPROM, shutddown,
		etc. The action ids are defined in ENUM MAV_ACTION in
		mavlink/include/mavlink_types.h

		target            	: The system executing the action (uint8_t)
		target_component  	: The component executing the action (uint8_t)
		action            	: The action id (uint8_t)

		'''
		return self.send(self.action_encode(target, target_component, action))

	def action_ack_encode(self, action, result):
		'''
		This message acknowledges an action. IMPORTANT: The acknowledgement
		can be also negative, e.g. the MAV rejects a reset message because
		it is in-flight. The action ids are defined in ENUM MAV_ACTION in
		mavlink/include/mavlink_types.h

		action            	: The action id (uint8_t)
		result            	: 0: Action DENIED, 1: Action executed (uint8_t)

		'''
		msg = MAVLink_action_ack_message(action, result)
		msg.pack(self)
                return msg

	def action_ack_send(self, action, result):
		'''
		This message acknowledges an action. IMPORTANT: The acknowledgement
		can be also negative, e.g. the MAV rejects a reset message because
		it is in-flight. The action ids are defined in ENUM MAV_ACTION in
		mavlink/include/mavlink_types.h

		action            	: The action id (uint8_t)
		result            	: 0: Action DENIED, 1: Action executed (uint8_t)

		'''
		return self.send(self.action_ack_encode(action, result))

	def set_mode_encode(self, target, mode):
		'''
		Set the system mode, as defined by enum MAV_MODE in
		mavlink/include/mavlink_types.h. There is no target component id as
		the mode is by definition for the overall aircraft, not only for one
		component.

		target            	: The system setting the mode (uint8_t)
		mode              	: The new mode (uint8_t)

		'''
		msg = MAVLink_set_mode_message(target, mode)
		msg.pack(self)
                return msg

	def set_mode_send(self, target, mode):
		'''
		Set the system mode, as defined by enum MAV_MODE in
		mavlink/include/mavlink_types.h. There is no target component id as
		the mode is by definition for the overall aircraft, not only for one
		component.

		target            	: The system setting the mode (uint8_t)
		mode              	: The new mode (uint8_t)

		'''
		return self.send(self.set_mode_encode(target, mode))

	def set_nav_mode_encode(self, target, nav_mode):
		'''
		Set the system navigation mode, as defined by enum MAV_NAV_MODE in
		mavlink/include/mavlink_types.h. The navigation mode applies to the
		whole aircraft and thus all components.

		target            	: The system setting the mode (uint8_t)
		nav_mode          	: The new navigation mode (uint8_t)

		'''
		msg = MAVLink_set_nav_mode_message(target, nav_mode)
		msg.pack(self)
                return msg

	def set_nav_mode_send(self, target, nav_mode):
		'''
		Set the system navigation mode, as defined by enum MAV_NAV_MODE in
		mavlink/include/mavlink_types.h. The navigation mode applies to the
		whole aircraft and thus all components.

		target            	: The system setting the mode (uint8_t)
		nav_mode          	: The new navigation mode (uint8_t)

		'''
		return self.send(self.set_nav_mode_encode(target, nav_mode))

	def param_request_read_encode(self, target_system, target_component, param_id, param_index):
		'''
		Request to read the onboard parameter with the param_id string id.
		Onboard parameters are stored as key[const char*] -> value[float].
		This allows to send a parameter to any other component (such as the
		GCS) without the need of previous knowledge of possible parameter
		names. Thus the same GCS can store different parameters for
		different autopilots. See also
		http://qgroundcontrol.org/parameter_interface for a full
		documentation of QGroundControl and IMU code.

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)
		param_id          	: Onboard parameter id (array[15])
		param_index       	: Parameter index (uint16_t)

		'''
		msg = MAVLink_param_request_read_message(target_system, target_component, param_id, param_index)
		msg.pack(self)
                return msg

	def param_request_read_send(self, target_system, target_component, param_id, param_index):
		'''
		Request to read the onboard parameter with the param_id string id.
		Onboard parameters are stored as key[const char*] -> value[float].
		This allows to send a parameter to any other component (such as the
		GCS) without the need of previous knowledge of possible parameter
		names. Thus the same GCS can store different parameters for
		different autopilots. See also
		http://qgroundcontrol.org/parameter_interface for a full
		documentation of QGroundControl and IMU code.

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)
		param_id          	: Onboard parameter id (array[15])
		param_index       	: Parameter index (uint16_t)

		'''
		return self.send(self.param_request_read_encode(target_system, target_component, param_id, param_index))

	def param_request_list_encode(self, target_system, target_component):
		'''
		Request all parameters of this component. After his request, all
		parameters are emitted.

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)

		'''
		msg = MAVLink_param_request_list_message(target_system, target_component)
		msg.pack(self)
                return msg

	def param_request_list_send(self, target_system, target_component):
		'''
		Request all parameters of this component. After his request, all
		parameters are emitted.

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)

		'''
		return self.send(self.param_request_list_encode(target_system, target_component))

	def param_value_encode(self, param_id, param_value, param_count, param_index):
		'''
		Emit the value of a onboard parameter. The inclusion of param_count
		and param_index in the message allows the recipient to keep track of
		received parameters and allows him to re-request missing parameters
		after a loss or timeout.

		param_id          	: Onboard parameter id (array[15])
		param_value       	: Onboard parameter value (float)
		param_count       	: Total number of onboard parameters (uint16_t)
		param_index       	: Index of this onboard parameter (uint16_t)

		'''
		msg = MAVLink_param_value_message(param_id, param_value, param_count, param_index)
		msg.pack(self)
                return msg

	def param_value_send(self, param_id, param_value, param_count, param_index):
		'''
		Emit the value of a onboard parameter. The inclusion of param_count
		and param_index in the message allows the recipient to keep track of
		received parameters and allows him to re-request missing parameters
		after a loss or timeout.

		param_id          	: Onboard parameter id (array[15])
		param_value       	: Onboard parameter value (float)
		param_count       	: Total number of onboard parameters (uint16_t)
		param_index       	: Index of this onboard parameter (uint16_t)

		'''
		return self.send(self.param_value_encode(param_id, param_value, param_count, param_index))

	def param_set_encode(self, target_system, target_component, param_id, param_value):
		'''
		Set a parameter value TEMPORARILY to RAM. It will be reset to default
		on system reboot. Send the ACTION MAV_ACTION_STORAGE_WRITE to
		PERMANENTLY write the RAM contents to EEPROM. IMPORTANT: The
		receiving component should acknowledge the new parameter value by
		sending a param_value message to all communication partners. This
		will also ensure that multiple GCS all have an up-to-date list of
		all parameters. If the sending GCS did not receive a PARAM_VALUE
		message within its timeout time, it should re-send the PARAM_SET
		message.

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)
		param_id          	: Onboard parameter id (array[15])
		param_value       	: Onboard parameter value (float)

		'''
		msg = MAVLink_param_set_message(target_system, target_component, param_id, param_value)
		msg.pack(self)
                return msg

	def param_set_send(self, target_system, target_component, param_id, param_value):
		'''
		Set a parameter value TEMPORARILY to RAM. It will be reset to default
		on system reboot. Send the ACTION MAV_ACTION_STORAGE_WRITE to
		PERMANENTLY write the RAM contents to EEPROM. IMPORTANT: The
		receiving component should acknowledge the new parameter value by
		sending a param_value message to all communication partners. This
		will also ensure that multiple GCS all have an up-to-date list of
		all parameters. If the sending GCS did not receive a PARAM_VALUE
		message within its timeout time, it should re-send the PARAM_SET
		message.

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)
		param_id          	: Onboard parameter id (array[15])
		param_value       	: Onboard parameter value (float)

		'''
		return self.send(self.param_set_encode(target_system, target_component, param_id, param_value))

	def raw_imu_encode(self, usec, xacc, yacc, zacc, xgyro, ygyro, zgyro, xmag, ymag, zmag):
		'''
		The RAW IMU readings for the usual 9DOF sensor setup. This message
		should always contain the true raw values without any scaling to
		allow data capture and system debugging.

		usec              	: Timestamp (microseconds since UNIX epoch) (uint64_t)
		xacc              	: X acceleration (mg raw) (int16_t)
		yacc              	: Y acceleration (mg raw) (int16_t)
		zacc              	: Z acceleration (mg raw) (int16_t)
		xgyro             	: Angular speed around X axis (millirad /sec) (int16_t)
		ygyro             	: Angular speed around Y axis (millirad /sec) (int16_t)
		zgyro             	: Angular speed around Z axis (millirad /sec) (int16_t)
		xmag              	: X Magnetic field (milli tesla) (int16_t)
		ymag              	: Y Magnetic field (milli tesla) (int16_t)
		zmag              	: Z Magnetic field (milli tesla) (int16_t)

		'''
		msg = MAVLink_raw_imu_message(usec, xacc, yacc, zacc, xgyro, ygyro, zgyro, xmag, ymag, zmag)
		msg.pack(self)
                return msg

	def raw_imu_send(self, usec, xacc, yacc, zacc, xgyro, ygyro, zgyro, xmag, ymag, zmag):
		'''
		The RAW IMU readings for the usual 9DOF sensor setup. This message
		should always contain the true raw values without any scaling to
		allow data capture and system debugging.

		usec              	: Timestamp (microseconds since UNIX epoch) (uint64_t)
		xacc              	: X acceleration (mg raw) (int16_t)
		yacc              	: Y acceleration (mg raw) (int16_t)
		zacc              	: Z acceleration (mg raw) (int16_t)
		xgyro             	: Angular speed around X axis (millirad /sec) (int16_t)
		ygyro             	: Angular speed around Y axis (millirad /sec) (int16_t)
		zgyro             	: Angular speed around Z axis (millirad /sec) (int16_t)
		xmag              	: X Magnetic field (milli tesla) (int16_t)
		ymag              	: Y Magnetic field (milli tesla) (int16_t)
		zmag              	: Z Magnetic field (milli tesla) (int16_t)

		'''
		return self.send(self.raw_imu_encode(usec, xacc, yacc, zacc, xgyro, ygyro, zgyro, xmag, ymag, zmag))

	def raw_pressure_encode(self, usec, press_abs, press_diff1, press_diff2, temperature):
		'''
		The RAW pressure readings for the typical setup of one absolute
		pressure and one differential pressure sensor. The sensor values
		should be the raw, unscaled ADC values.

		usec              	: Timestamp (microseconds since UNIX epoch) (uint64_t)
		press_abs         	: Absolute pressure (hectopascal) (uint16_t)
		press_diff1       	: Differential pressure 1 (hectopascal) (int16_t)
		press_diff2       	: Differential pressure 2 (hectopascal) (int16_t)
		temperature       	: Raw Temperature measurement (0.01 degrees celsius per tick is default unit) (int16_t)

		'''
		msg = MAVLink_raw_pressure_message(usec, press_abs, press_diff1, press_diff2, temperature)
		msg.pack(self)
                return msg

	def raw_pressure_send(self, usec, press_abs, press_diff1, press_diff2, temperature):
		'''
		The RAW pressure readings for the typical setup of one absolute
		pressure and one differential pressure sensor. The sensor values
		should be the raw, unscaled ADC values.

		usec              	: Timestamp (microseconds since UNIX epoch) (uint64_t)
		press_abs         	: Absolute pressure (hectopascal) (uint16_t)
		press_diff1       	: Differential pressure 1 (hectopascal) (int16_t)
		press_diff2       	: Differential pressure 2 (hectopascal) (int16_t)
		temperature       	: Raw Temperature measurement (0.01 degrees celsius per tick is default unit) (int16_t)

		'''
		return self.send(self.raw_pressure_encode(usec, press_abs, press_diff1, press_diff2, temperature))

	def attitude_encode(self, usec, roll, pitch, yaw, rollspeed, pitchspeed, yawspeed):
		'''
		The attitude in the aeronautical frame (right-handed, Z-down, X-front,
		Y-right).

		usec              	: Timestamp (microseconds) (uint64_t)
		roll              	: Roll angle (rad) (float)
		pitch             	: Pitch angle (rad) (float)
		yaw               	: Yaw angle (rad) (float)
		rollspeed         	: Roll angular speed (rad/s) (float)
		pitchspeed        	: Pitch angular speed (rad/s) (float)
		yawspeed          	: Yaw angular speed (rad/s) (float)

		'''
		msg = MAVLink_attitude_message(usec, roll, pitch, yaw, rollspeed, pitchspeed, yawspeed)
		msg.pack(self)
                return msg

	def attitude_send(self, usec, roll, pitch, yaw, rollspeed, pitchspeed, yawspeed):
		'''
		The attitude in the aeronautical frame (right-handed, Z-down, X-front,
		Y-right).

		usec              	: Timestamp (microseconds) (uint64_t)
		roll              	: Roll angle (rad) (float)
		pitch             	: Pitch angle (rad) (float)
		yaw               	: Yaw angle (rad) (float)
		rollspeed         	: Roll angular speed (rad/s) (float)
		pitchspeed        	: Pitch angular speed (rad/s) (float)
		yawspeed          	: Yaw angular speed (rad/s) (float)

		'''
		return self.send(self.attitude_encode(usec, roll, pitch, yaw, rollspeed, pitchspeed, yawspeed))

	def local_position_encode(self, usec, x, y, z, vx, vy, vz):
		'''
		The filtered local position (e.g. fused computer vision and
		accelerometers).

		usec              	: Timestamp (microseconds since unix epoch) (uint64_t)
		x                 	: X Position (float)
		y                 	: Y Position (float)
		z                 	: Z Position (float)
		vx                	: X Speed (float)
		vy                	: Y Speed (float)
		vz                	: Z Speed (float)

		'''
		msg = MAVLink_local_position_message(usec, x, y, z, vx, vy, vz)
		msg.pack(self)
                return msg

	def local_position_send(self, usec, x, y, z, vx, vy, vz):
		'''
		The filtered local position (e.g. fused computer vision and
		accelerometers).

		usec              	: Timestamp (microseconds since unix epoch) (uint64_t)
		x                 	: X Position (float)
		y                 	: Y Position (float)
		z                 	: Z Position (float)
		vx                	: X Speed (float)
		vy                	: Y Speed (float)
		vz                	: Z Speed (float)

		'''
		return self.send(self.local_position_encode(usec, x, y, z, vx, vy, vz))

	def gps_raw_encode(self, usec, fix_type, lat, lon, alt, eph, epv, v, hdg):
		'''
		The global position, as returned by the Global Positioning System
		(GPS). This is NOT the global position estimate of the sytem, but
		rather a RAW sensor value. See message GLOBAL_POSITION for the
		global position estimate.

		usec              	: Timestamp (microseconds since unix epoch) (uint64_t)
		fix_type          	: 0-1: no fix, 2: 2D fix, 3: 3D fix (uint8_t)
		lat               	: X Position (float)
		lon               	: Y Position (float)
		alt               	: Z Position in meters (float)
		eph               	: Uncertainty in meters of latitude (float)
		epv               	: Uncertainty in meters of longitude (float)
		v                 	: Overall speed (float)
		hdg               	: Heading, in FIXME (float)

		'''
		msg = MAVLink_gps_raw_message(usec, fix_type, lat, lon, alt, eph, epv, v, hdg)
		msg.pack(self)
                return msg

	def gps_raw_send(self, usec, fix_type, lat, lon, alt, eph, epv, v, hdg):
		'''
		The global position, as returned by the Global Positioning System
		(GPS). This is NOT the global position estimate of the sytem, but
		rather a RAW sensor value. See message GLOBAL_POSITION for the
		global position estimate.

		usec              	: Timestamp (microseconds since unix epoch) (uint64_t)
		fix_type          	: 0-1: no fix, 2: 2D fix, 3: 3D fix (uint8_t)
		lat               	: X Position (float)
		lon               	: Y Position (float)
		alt               	: Z Position in meters (float)
		eph               	: Uncertainty in meters of latitude (float)
		epv               	: Uncertainty in meters of longitude (float)
		v                 	: Overall speed (float)
		hdg               	: Heading, in FIXME (float)

		'''
		return self.send(self.gps_raw_encode(usec, fix_type, lat, lon, alt, eph, epv, v, hdg))

	def gps_status_encode(self, satellites_visible, satellite_prn, satellite_used, satellite_elevation, satellite_azimuth, satellite_snr):
		'''
		The global position, as returned by the Global Positioning System
		(GPS). This is NOT the global position estimate of the sytem, but
		rather a RAW sensor value. See message GLOBAL_POSITION for the
		global position estimate. This message can contain information for
		up to 20 satellites.

		satellites_visible	: Number of satellites visible (uint8_t)
		satellite_prn     	: Global satellite ID (array[20])
		satellite_used    	: 0: Satellite not used, 1: used for localization (array[20])
		satellite_elevation	: Elevation (0: right on top of receiver, 90: on the horizon) of satellite (array[20])
		satellite_azimuth 	: Direction of satellite, 0: 0 deg, 255: 360 deg. (array[20])
		satellite_snr     	: Signal to noise ratio of satellite (array[20])

		'''
		msg = MAVLink_gps_status_message(satellites_visible, satellite_prn, satellite_used, satellite_elevation, satellite_azimuth, satellite_snr)
		msg.pack(self)
                return msg

	def gps_status_send(self, satellites_visible, satellite_prn, satellite_used, satellite_elevation, satellite_azimuth, satellite_snr):
		'''
		The global position, as returned by the Global Positioning System
		(GPS). This is NOT the global position estimate of the sytem, but
		rather a RAW sensor value. See message GLOBAL_POSITION for the
		global position estimate. This message can contain information for
		up to 20 satellites.

		satellites_visible	: Number of satellites visible (uint8_t)
		satellite_prn     	: Global satellite ID (array[20])
		satellite_used    	: 0: Satellite not used, 1: used for localization (array[20])
		satellite_elevation	: Elevation (0: right on top of receiver, 90: on the horizon) of satellite (array[20])
		satellite_azimuth 	: Direction of satellite, 0: 0 deg, 255: 360 deg. (array[20])
		satellite_snr     	: Signal to noise ratio of satellite (array[20])

		'''
		return self.send(self.gps_status_encode(satellites_visible, satellite_prn, satellite_used, satellite_elevation, satellite_azimuth, satellite_snr))

	def global_position_encode(self, usec, lat, lon, alt, vx, vy, vz):
		'''
		The filtered global position (e.g. fused GPS and accelerometers).

		usec              	: Timestamp (microseconds since unix epoch) (uint64_t)
		lat               	: X Position (float)
		lon               	: Y Position (float)
		alt               	: Z Position (float)
		vx                	: X Speed (float)
		vy                	: Y Speed (float)
		vz                	: Z Speed (float)

		'''
		msg = MAVLink_global_position_message(usec, lat, lon, alt, vx, vy, vz)
		msg.pack(self)
                return msg

	def global_position_send(self, usec, lat, lon, alt, vx, vy, vz):
		'''
		The filtered global position (e.g. fused GPS and accelerometers).

		usec              	: Timestamp (microseconds since unix epoch) (uint64_t)
		lat               	: X Position (float)
		lon               	: Y Position (float)
		alt               	: Z Position (float)
		vx                	: X Speed (float)
		vy                	: Y Speed (float)
		vz                	: Z Speed (float)

		'''
		return self.send(self.global_position_encode(usec, lat, lon, alt, vx, vy, vz))

	def sys_status_encode(self, mode, nav_mode, status, load, vbat, motor_block, packet_drop):
		'''
		The general system state. If the system is following the MAVLink
		standard, the system state is mainly defined by three orthogonal
		states/modes: The system mode, which is either LOCKED (motors shut
		down and locked), MANUAL (system under RC control), GUIDED (system
		with autonomous position control, position setpoint controlled
		manually) or AUTO (system guided by path/waypoint planner). The
		NAV_MODE defined the current flight state: LIFTOFF (often an open-
		loop maneuver), LANDING, WAYPOINTS or VECTOR. This represents the
		internal navigation state machine. The system status shows wether
		the system is currently active or not and if an emergency occured.
		During the CRITICAL and EMERGENCY states the MAV is still considered
		to be active, but should start emergency procedures autonomously.
		After a failure occured it should first move from active to critical
		to allow manual intervention and then move to emergency after a
		certain timeout.

		mode              	: System mode, see MAV_MODE ENUM in mavlink/include/mavlink_types.h (uint8_t)
		nav_mode          	: Navigation mode, see MAV_NAV_MODE ENUM (uint8_t)
		status            	: System status flag, see MAV_STATUS ENUM (uint8_t)
		load              	: Maximum usage in percent of the mainloop time, (0%: 0, 100%: 1000) should be always below 1000 (uint16_t)
		vbat              	: Battery voltage, in millivolts (1 = 1 millivolt) (uint16_t)
		motor_block       	: Motor block status flag, 0: Motors can be switched on (and could be either off or on), 1: Mechanical motor block switch is on, motors cannot be switched on (and are definitely off) (uint8_t)
		packet_drop       	: Dropped packets (packets that were corrupted on reception on the MAV) (uint16_t)

		'''
		msg = MAVLink_sys_status_message(mode, nav_mode, status, load, vbat, motor_block, packet_drop)
		msg.pack(self)
                return msg

	def sys_status_send(self, mode, nav_mode, status, load, vbat, motor_block, packet_drop):
		'''
		The general system state. If the system is following the MAVLink
		standard, the system state is mainly defined by three orthogonal
		states/modes: The system mode, which is either LOCKED (motors shut
		down and locked), MANUAL (system under RC control), GUIDED (system
		with autonomous position control, position setpoint controlled
		manually) or AUTO (system guided by path/waypoint planner). The
		NAV_MODE defined the current flight state: LIFTOFF (often an open-
		loop maneuver), LANDING, WAYPOINTS or VECTOR. This represents the
		internal navigation state machine. The system status shows wether
		the system is currently active or not and if an emergency occured.
		During the CRITICAL and EMERGENCY states the MAV is still considered
		to be active, but should start emergency procedures autonomously.
		After a failure occured it should first move from active to critical
		to allow manual intervention and then move to emergency after a
		certain timeout.

		mode              	: System mode, see MAV_MODE ENUM in mavlink/include/mavlink_types.h (uint8_t)
		nav_mode          	: Navigation mode, see MAV_NAV_MODE ENUM (uint8_t)
		status            	: System status flag, see MAV_STATUS ENUM (uint8_t)
		load              	: Maximum usage in percent of the mainloop time, (0%: 0, 100%: 1000) should be always below 1000 (uint16_t)
		vbat              	: Battery voltage, in millivolts (1 = 1 millivolt) (uint16_t)
		motor_block       	: Motor block status flag, 0: Motors can be switched on (and could be either off or on), 1: Mechanical motor block switch is on, motors cannot be switched on (and are definitely off) (uint8_t)
		packet_drop       	: Dropped packets (packets that were corrupted on reception on the MAV) (uint16_t)

		'''
		return self.send(self.sys_status_encode(mode, nav_mode, status, load, vbat, motor_block, packet_drop))

	def rc_channels_raw_encode(self, chan1_raw, chan2_raw, chan3_raw, chan4_raw, chan5_raw, chan6_raw, chan7_raw, chan8_raw, rssi):
		'''
		The RAW values of the RC channels received. The standard PPM
		modulation is as follows: 1000 microseconds: 0%, 2000 microseconds:
		100%. Individual receivers/transmitters might violate this
		specification.

		chan1_raw         	: RC channel 1 value, in microseconds (uint16_t)
		chan2_raw         	: RC channel 2 value, in microseconds (uint16_t)
		chan3_raw         	: RC channel 3 value, in microseconds (uint16_t)
		chan4_raw         	: RC channel 4 value, in microseconds (uint16_t)
		chan5_raw         	: RC channel 5 value, in microseconds (uint16_t)
		chan6_raw         	: RC channel 6 value, in microseconds (uint16_t)
		chan7_raw         	: RC channel 7 value, in microseconds (uint16_t)
		chan8_raw         	: RC channel 8 value, in microseconds (uint16_t)
		rssi              	: Receive signal strength indicator, 0: 0%, 255: 100% (uint8_t)

		'''
		msg = MAVLink_rc_channels_raw_message(chan1_raw, chan2_raw, chan3_raw, chan4_raw, chan5_raw, chan6_raw, chan7_raw, chan8_raw, rssi)
		msg.pack(self)
                return msg

	def rc_channels_raw_send(self, chan1_raw, chan2_raw, chan3_raw, chan4_raw, chan5_raw, chan6_raw, chan7_raw, chan8_raw, rssi):
		'''
		The RAW values of the RC channels received. The standard PPM
		modulation is as follows: 1000 microseconds: 0%, 2000 microseconds:
		100%. Individual receivers/transmitters might violate this
		specification.

		chan1_raw         	: RC channel 1 value, in microseconds (uint16_t)
		chan2_raw         	: RC channel 2 value, in microseconds (uint16_t)
		chan3_raw         	: RC channel 3 value, in microseconds (uint16_t)
		chan4_raw         	: RC channel 4 value, in microseconds (uint16_t)
		chan5_raw         	: RC channel 5 value, in microseconds (uint16_t)
		chan6_raw         	: RC channel 6 value, in microseconds (uint16_t)
		chan7_raw         	: RC channel 7 value, in microseconds (uint16_t)
		chan8_raw         	: RC channel 8 value, in microseconds (uint16_t)
		rssi              	: Receive signal strength indicator, 0: 0%, 255: 100% (uint8_t)

		'''
		return self.send(self.rc_channels_raw_encode(chan1_raw, chan2_raw, chan3_raw, chan4_raw, chan5_raw, chan6_raw, chan7_raw, chan8_raw, rssi))

	def rc_channels_scaled_encode(self, chan1_scaled, chan2_scaled, chan3_scaled, chan4_scaled, chan5_scaled, chan6_scaled, chan7_scaled, chan8_scaled, rssi):
		'''
		The scaled values of the RC channels received. (-100%) -10000, (0%) 0,
		(100%) 10000

		chan1_scaled      	: RC channel 1 value scaled, (-100%) -10000, (0%) 0, (100%) 10000 (int16_t)
		chan2_scaled      	: RC channel 2 value scaled, (-100%) -10000, (0%) 0, (100%) 10000 (int16_t)
		chan3_scaled      	: RC channel 3 value scaled, (-100%) -10000, (0%) 0, (100%) 10000 (int16_t)
		chan4_scaled      	: RC channel 4 value scaled, (-100%) -10000, (0%) 0, (100%) 10000 (int16_t)
		chan5_scaled      	: RC channel 5 value scaled, (-100%) -10000, (0%) 0, (100%) 10000 (int16_t)
		chan6_scaled      	: RC channel 6 value scaled, (-100%) -10000, (0%) 0, (100%) 10000 (int16_t)
		chan7_scaled      	: RC channel 7 value scaled, (-100%) -10000, (0%) 0, (100%) 10000 (int16_t)
		chan8_scaled      	: RC channel 8 value scaled, (-100%) -10000, (0%) 0, (100%) 10000 (int16_t)
		rssi              	: Receive signal strength indicator, 0: 0%, 255: 100% (uint8_t)

		'''
		msg = MAVLink_rc_channels_scaled_message(chan1_scaled, chan2_scaled, chan3_scaled, chan4_scaled, chan5_scaled, chan6_scaled, chan7_scaled, chan8_scaled, rssi)
		msg.pack(self)
                return msg

	def rc_channels_scaled_send(self, chan1_scaled, chan2_scaled, chan3_scaled, chan4_scaled, chan5_scaled, chan6_scaled, chan7_scaled, chan8_scaled, rssi):
		'''
		The scaled values of the RC channels received. (-100%) -10000, (0%) 0,
		(100%) 10000

		chan1_scaled      	: RC channel 1 value scaled, (-100%) -10000, (0%) 0, (100%) 10000 (int16_t)
		chan2_scaled      	: RC channel 2 value scaled, (-100%) -10000, (0%) 0, (100%) 10000 (int16_t)
		chan3_scaled      	: RC channel 3 value scaled, (-100%) -10000, (0%) 0, (100%) 10000 (int16_t)
		chan4_scaled      	: RC channel 4 value scaled, (-100%) -10000, (0%) 0, (100%) 10000 (int16_t)
		chan5_scaled      	: RC channel 5 value scaled, (-100%) -10000, (0%) 0, (100%) 10000 (int16_t)
		chan6_scaled      	: RC channel 6 value scaled, (-100%) -10000, (0%) 0, (100%) 10000 (int16_t)
		chan7_scaled      	: RC channel 7 value scaled, (-100%) -10000, (0%) 0, (100%) 10000 (int16_t)
		chan8_scaled      	: RC channel 8 value scaled, (-100%) -10000, (0%) 0, (100%) 10000 (int16_t)
		rssi              	: Receive signal strength indicator, 0: 0%, 255: 100% (uint8_t)

		'''
		return self.send(self.rc_channels_scaled_encode(chan1_scaled, chan2_scaled, chan3_scaled, chan4_scaled, chan5_scaled, chan6_scaled, chan7_scaled, chan8_scaled, rssi))

	def waypoint_encode(self, target_system, target_component, seq, frame, action, orbit, orbit_direction, param1, param2, current, x, y, z, yaw, autocontinue):
		'''
		Message encoding a waypoint. This message is emitted to announce
		the presence of a waypoint. It cannot be used to set a waypoint, use
		WAYPOINT_SET for this purpose. The waypoint can be either in x, y, z
		meters (type: LOCAL) or x:lat, y:lon. The global and body frame are
		related as: positive Z-down, positive X(front looking north,
		positive Y(body:right) looking east. Therefore y encodes in global
		mode the latitude, whereas x encodes the longitude and z the GPS
		altitude (WGS84).

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)
		seq               	: Sequence (uint16_t)
		frame             	: The coordinate system of the waypoint. see MAV_FRAME in mavlink_types.h (uint8_t)
		action            	: The scheduled action for the waypoint. see MAV_ACTION in mavlink_types.h (uint8_t)
		orbit             	: Orbit to circle around the waypoint, in meters. Set to 0 to fly straight through the waypoint (float)
		orbit_direction   	: Direction of the orbit circling: 0: clockwise, 1: counter-clockwise (uint8_t)
		param1            	: For waypoints of type 0 and 1: Radius in which the waypoint is accepted as reached, in meters (float)
		param2            	: For waypoints of type 0 and 1: Time that the MAV should stay inside the orbit before advancing, in milliseconds (float)
		current           	: false:0, true:1 (uint8_t)
		x                 	: local: x position, global: longitude (float)
		y                 	: y position: global: latitude (float)
		z                 	: z position: global: altitude (float)
		yaw               	: yaw orientation in radians, 0 = NORTH (float)
		autocontinue      	: autocontinue to next wp (uint8_t)

		'''
		msg = MAVLink_waypoint_message(target_system, target_component, seq, frame, action, orbit, orbit_direction, param1, param2, current, x, y, z, yaw, autocontinue)
		msg.pack(self)
                return msg

	def waypoint_send(self, target_system, target_component, seq, frame, action, orbit, orbit_direction, param1, param2, current, x, y, z, yaw, autocontinue):
		'''
		Message encoding a waypoint. This message is emitted to announce
		the presence of a waypoint. It cannot be used to set a waypoint, use
		WAYPOINT_SET for this purpose. The waypoint can be either in x, y, z
		meters (type: LOCAL) or x:lat, y:lon. The global and body frame are
		related as: positive Z-down, positive X(front looking north,
		positive Y(body:right) looking east. Therefore y encodes in global
		mode the latitude, whereas x encodes the longitude and z the GPS
		altitude (WGS84).

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)
		seq               	: Sequence (uint16_t)
		frame             	: The coordinate system of the waypoint. see MAV_FRAME in mavlink_types.h (uint8_t)
		action            	: The scheduled action for the waypoint. see MAV_ACTION in mavlink_types.h (uint8_t)
		orbit             	: Orbit to circle around the waypoint, in meters. Set to 0 to fly straight through the waypoint (float)
		orbit_direction   	: Direction of the orbit circling: 0: clockwise, 1: counter-clockwise (uint8_t)
		param1            	: For waypoints of type 0 and 1: Radius in which the waypoint is accepted as reached, in meters (float)
		param2            	: For waypoints of type 0 and 1: Time that the MAV should stay inside the orbit before advancing, in milliseconds (float)
		current           	: false:0, true:1 (uint8_t)
		x                 	: local: x position, global: longitude (float)
		y                 	: y position: global: latitude (float)
		z                 	: z position: global: altitude (float)
		yaw               	: yaw orientation in radians, 0 = NORTH (float)
		autocontinue      	: autocontinue to next wp (uint8_t)

		'''
		return self.send(self.waypoint_encode(target_system, target_component, seq, frame, action, orbit, orbit_direction, param1, param2, current, x, y, z, yaw, autocontinue))

	def waypoint_request_encode(self, target_system, target_component, seq):
		'''
		Request the information of the waypoint with the sequence number seq.
		The response of the system to this message should be a WAYPOINT
		message.

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)
		seq               	: Sequence (uint16_t)

		'''
		msg = MAVLink_waypoint_request_message(target_system, target_component, seq)
		msg.pack(self)
                return msg

	def waypoint_request_send(self, target_system, target_component, seq):
		'''
		Request the information of the waypoint with the sequence number seq.
		The response of the system to this message should be a WAYPOINT
		message.

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)
		seq               	: Sequence (uint16_t)

		'''
		return self.send(self.waypoint_request_encode(target_system, target_component, seq))

	def waypoint_set_current_encode(self, target_system, target_component, seq):
		'''
		Set the waypoint with sequence number seq as current waypoint. This
		means that the MAV will continue to this waypoint on the shortest
		path (not following the waypoints in-between).

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)
		seq               	: Sequence (uint16_t)

		'''
		msg = MAVLink_waypoint_set_current_message(target_system, target_component, seq)
		msg.pack(self)
                return msg

	def waypoint_set_current_send(self, target_system, target_component, seq):
		'''
		Set the waypoint with sequence number seq as current waypoint. This
		means that the MAV will continue to this waypoint on the shortest
		path (not following the waypoints in-between).

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)
		seq               	: Sequence (uint16_t)

		'''
		return self.send(self.waypoint_set_current_encode(target_system, target_component, seq))

	def waypoint_current_encode(self, seq):
		'''
		Message that announces the sequence number of the current active
		waypoint. The MAV will fly towards this waypoint.

		seq               	: Sequence (uint16_t)

		'''
		msg = MAVLink_waypoint_current_message(seq)
		msg.pack(self)
                return msg

	def waypoint_current_send(self, seq):
		'''
		Message that announces the sequence number of the current active
		waypoint. The MAV will fly towards this waypoint.

		seq               	: Sequence (uint16_t)

		'''
		return self.send(self.waypoint_current_encode(seq))

	def waypoint_request_list_encode(self, target_system, target_component):
		'''
		Request the overall list of waypoints from the system/component.

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)

		'''
		msg = MAVLink_waypoint_request_list_message(target_system, target_component)
		msg.pack(self)
                return msg

	def waypoint_request_list_send(self, target_system, target_component):
		'''
		Request the overall list of waypoints from the system/component.

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)

		'''
		return self.send(self.waypoint_request_list_encode(target_system, target_component))

	def waypoint_count_encode(self, target_system, target_component, count):
		'''
		This message is emitted as response to WAYPOINT_REQUEST_LIST by the
		MAV. The GCS can then request the individual waypoints based on the
		knowledge of the total number of waypoints.

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)
		count             	: Number of Waypoints in the Sequence (uint16_t)

		'''
		msg = MAVLink_waypoint_count_message(target_system, target_component, count)
		msg.pack(self)
                return msg

	def waypoint_count_send(self, target_system, target_component, count):
		'''
		This message is emitted as response to WAYPOINT_REQUEST_LIST by the
		MAV. The GCS can then request the individual waypoints based on the
		knowledge of the total number of waypoints.

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)
		count             	: Number of Waypoints in the Sequence (uint16_t)

		'''
		return self.send(self.waypoint_count_encode(target_system, target_component, count))

	def waypoint_clear_all_encode(self, target_system, target_component):
		'''
		Delete all waypoints at once.

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)

		'''
		msg = MAVLink_waypoint_clear_all_message(target_system, target_component)
		msg.pack(self)
                return msg

	def waypoint_clear_all_send(self, target_system, target_component):
		'''
		Delete all waypoints at once.

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)

		'''
		return self.send(self.waypoint_clear_all_encode(target_system, target_component))

	def waypoint_reached_encode(self, seq):
		'''
		A certain waypoint has been reached. The system will either hold this
		position (or circle on the orbit) or (if the autocontinue on the WP
		was set) continue to the next waypoint.

		seq               	: Sequence (uint16_t)

		'''
		msg = MAVLink_waypoint_reached_message(seq)
		msg.pack(self)
                return msg

	def waypoint_reached_send(self, seq):
		'''
		A certain waypoint has been reached. The system will either hold this
		position (or circle on the orbit) or (if the autocontinue on the WP
		was set) continue to the next waypoint.

		seq               	: Sequence (uint16_t)

		'''
		return self.send(self.waypoint_reached_encode(seq))

	def waypoint_ack_encode(self, target_system, target_component, type):
		'''
		Ack message during waypoint handling. The type field states if this
		message is a positive ack (type=0) or if an error happened (type
		=non-zero).

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)
		type              	: 0: OK, 1: Error (uint8_t)

		'''
		msg = MAVLink_waypoint_ack_message(target_system, target_component, type)
		msg.pack(self)
                return msg

	def waypoint_ack_send(self, target_system, target_component, type):
		'''
		Ack message during waypoint handling. The type field states if this
		message is a positive ack (type=0) or if an error happened (type
		=non-zero).

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)
		type              	: 0: OK, 1: Error (uint8_t)

		'''
		return self.send(self.waypoint_ack_encode(target_system, target_component, type))

	def waypoint_set_global_reference_encode(self, target_system, target_component, global_x, global_y, global_z, global_yaw, local_x, local_y, local_z, local_yaw):
		'''
		As local waypoints exist, the global waypoint reference allows to
		transform between the local coordinate frame and the global (GPS)
		coordinate frame. This can be necessary when e.g. in- and outdoor
		settings are connected and the MAV should move from in- to outdoor.

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)
		global_x          	: global x position (float)
		global_y          	: global y position (float)
		global_z          	: global z position (float)
		global_yaw        	: global yaw orientation in radians, 0 = NORTH (float)
		local_x           	: local x position that matches the global x position (float)
		local_y           	: local y position that matches the global y position (float)
		local_z           	: local z position that matches the global z position (float)
		local_yaw         	: local yaw that matches the global yaw orientation (float)

		'''
		msg = MAVLink_waypoint_set_global_reference_message(target_system, target_component, global_x, global_y, global_z, global_yaw, local_x, local_y, local_z, local_yaw)
		msg.pack(self)
                return msg

	def waypoint_set_global_reference_send(self, target_system, target_component, global_x, global_y, global_z, global_yaw, local_x, local_y, local_z, local_yaw):
		'''
		As local waypoints exist, the global waypoint reference allows to
		transform between the local coordinate frame and the global (GPS)
		coordinate frame. This can be necessary when e.g. in- and outdoor
		settings are connected and the MAV should move from in- to outdoor.

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)
		global_x          	: global x position (float)
		global_y          	: global y position (float)
		global_z          	: global z position (float)
		global_yaw        	: global yaw orientation in radians, 0 = NORTH (float)
		local_x           	: local x position that matches the global x position (float)
		local_y           	: local y position that matches the global y position (float)
		local_z           	: local z position that matches the global z position (float)
		local_yaw         	: local yaw that matches the global yaw orientation (float)

		'''
		return self.send(self.waypoint_set_global_reference_encode(target_system, target_component, global_x, global_y, global_z, global_yaw, local_x, local_y, local_z, local_yaw))

	def local_position_setpoint_set_encode(self, target_system, target_component, x, y, z, yaw):
		'''
		Set the setpoint for a local position controller. This is the position
		in local coordinates the MAV should fly to. This message is sent by
		the path/waypoint planner to the onboard position controller. As
		some MAVs have a degree of freedom in yaw (e.g. all
		helicopters/quadrotors), the desired yaw angle is part of the
		message.

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)
		x                 	: x position 1 (float)
		y                 	: y position 1 (float)
		z                 	: z position 1 (float)
		yaw               	: x position 2 (float)

		'''
		msg = MAVLink_local_position_setpoint_set_message(target_system, target_component, x, y, z, yaw)
		msg.pack(self)
                return msg

	def local_position_setpoint_set_send(self, target_system, target_component, x, y, z, yaw):
		'''
		Set the setpoint for a local position controller. This is the position
		in local coordinates the MAV should fly to. This message is sent by
		the path/waypoint planner to the onboard position controller. As
		some MAVs have a degree of freedom in yaw (e.g. all
		helicopters/quadrotors), the desired yaw angle is part of the
		message.

		target_system     	: System ID (uint8_t)
		target_component  	: Component ID (uint8_t)
		x                 	: x position 1 (float)
		y                 	: y position 1 (float)
		z                 	: z position 1 (float)
		yaw               	: x position 2 (float)

		'''
		return self.send(self.local_position_setpoint_set_encode(target_system, target_component, x, y, z, yaw))

	def local_position_setpoint_encode(self, x, y, z, yaw):
		'''
		Transmit the current local setpoint of the controller to other MAVs
		(collision avoidance) and to the GCS.

		x                 	: x position 1 (float)
		y                 	: y position 1 (float)
		z                 	: z position 1 (float)
		yaw               	: x position 2 (float)

		'''
		msg = MAVLink_local_position_setpoint_message(x, y, z, yaw)
		msg.pack(self)
                return msg

	def local_position_setpoint_send(self, x, y, z, yaw):
		'''
		Transmit the current local setpoint of the controller to other MAVs
		(collision avoidance) and to the GCS.

		x                 	: x position 1 (float)
		y                 	: y position 1 (float)
		z                 	: z position 1 (float)
		yaw               	: x position 2 (float)

		'''
		return self.send(self.local_position_setpoint_encode(x, y, z, yaw))

	def attitude_controller_output_encode(self, enabled, roll, pitch, yaw, thrust):
		'''
		The output of the attitude controller. This output is the control
		response the controller currently generates and the attitude the MAV
		would take if it is under control of the attitude controller. The
		primary use of this message is to check the response and signs of
		the controller before the actual flight.

		enabled           	: 1: enabled, 0: disabled (uint8_t)
		roll              	: Attitude roll: -128: -100%, 127: +100% (int8_t)
		pitch             	: Attitude pitch: -128: -100%, 127: +100% (int8_t)
		yaw               	: Attitude yaw: -128: -100%, 127: +100% (int8_t)
		thrust            	: Attitude thrust: -128: -100%, 127: +100% (int8_t)

		'''
		msg = MAVLink_attitude_controller_output_message(enabled, roll, pitch, yaw, thrust)
		msg.pack(self)
                return msg

	def attitude_controller_output_send(self, enabled, roll, pitch, yaw, thrust):
		'''
		The output of the attitude controller. This output is the control
		response the controller currently generates and the attitude the MAV
		would take if it is under control of the attitude controller. The
		primary use of this message is to check the response and signs of
		the controller before the actual flight.

		enabled           	: 1: enabled, 0: disabled (uint8_t)
		roll              	: Attitude roll: -128: -100%, 127: +100% (int8_t)
		pitch             	: Attitude pitch: -128: -100%, 127: +100% (int8_t)
		yaw               	: Attitude yaw: -128: -100%, 127: +100% (int8_t)
		thrust            	: Attitude thrust: -128: -100%, 127: +100% (int8_t)

		'''
		return self.send(self.attitude_controller_output_encode(enabled, roll, pitch, yaw, thrust))

	def position_controller_output_encode(self, enabled, x, y, z, yaw):
		'''
		The output of the position controller. The primary use of this message
		is to check the response and signs of the controller before the
		actual flight.

		enabled           	: 1: enabled, 0: disabled (uint8_t)
		x                 	: Position x: -128: -100%, 127: +100% (int8_t)
		y                 	: Position y: -128: -100%, 127: +100% (int8_t)
		z                 	: Position z: -128: -100%, 127: +100% (int8_t)
		yaw               	: Position yaw: -128: -100%, 127: +100% (int8_t)

		'''
		msg = MAVLink_position_controller_output_message(enabled, x, y, z, yaw)
		msg.pack(self)
                return msg

	def position_controller_output_send(self, enabled, x, y, z, yaw):
		'''
		The output of the position controller. The primary use of this message
		is to check the response and signs of the controller before the
		actual flight.

		enabled           	: 1: enabled, 0: disabled (uint8_t)
		x                 	: Position x: -128: -100%, 127: +100% (int8_t)
		y                 	: Position y: -128: -100%, 127: +100% (int8_t)
		z                 	: Position z: -128: -100%, 127: +100% (int8_t)
		yaw               	: Position yaw: -128: -100%, 127: +100% (int8_t)

		'''
		return self.send(self.position_controller_output_encode(enabled, x, y, z, yaw))

	def position_target_encode(self, x, y, z, yaw):
		'''
		The goal position of the system. This position is the input to any
		navigation or path planning algorithm and does NOT represent the
		current controller setpoint.

		x                 	: x position (float)
		y                 	: y position (float)
		z                 	: z position (float)
		yaw               	: yaw orientation in radians, 0 = NORTH (float)

		'''
		msg = MAVLink_position_target_message(x, y, z, yaw)
		msg.pack(self)
                return msg

	def position_target_send(self, x, y, z, yaw):
		'''
		The goal position of the system. This position is the input to any
		navigation or path planning algorithm and does NOT represent the
		current controller setpoint.

		x                 	: x position (float)
		y                 	: y position (float)
		z                 	: z position (float)
		yaw               	: yaw orientation in radians, 0 = NORTH (float)

		'''
		return self.send(self.position_target_encode(x, y, z, yaw))

	def state_correction_encode(self, xErr, yErr, zErr, rollErr, pitchErr, yawErr, vxErr, vyErr, vzErr):
		'''
		Corrects the systems state by adding an error correction term to the
		position and velocity, and by rotating the attitude by a correction
		angle.

		xErr              	: x position error (float)
		yErr              	: y position error (float)
		zErr              	: z position error (float)
		rollErr           	: roll error (radians) (float)
		pitchErr          	: pitch error (radians) (float)
		yawErr            	: yaw error (radians) (float)
		vxErr             	: x velocity (float)
		vyErr             	: y velocity (float)
		vzErr             	: z velocity (float)

		'''
		msg = MAVLink_state_correction_message(xErr, yErr, zErr, rollErr, pitchErr, yawErr, vxErr, vyErr, vzErr)
		msg.pack(self)
                return msg

	def state_correction_send(self, xErr, yErr, zErr, rollErr, pitchErr, yawErr, vxErr, vyErr, vzErr):
		'''
		Corrects the systems state by adding an error correction term to the
		position and velocity, and by rotating the attitude by a correction
		angle.

		xErr              	: x position error (float)
		yErr              	: y position error (float)
		zErr              	: z position error (float)
		rollErr           	: roll error (radians) (float)
		pitchErr          	: pitch error (radians) (float)
		yawErr            	: yaw error (radians) (float)
		vxErr             	: x velocity (float)
		vyErr             	: y velocity (float)
		vzErr             	: z velocity (float)

		'''
		return self.send(self.state_correction_encode(xErr, yErr, zErr, rollErr, pitchErr, yawErr, vxErr, vyErr, vzErr))

	def set_altitude_encode(self, target, mode):
		'''
		

		target            	: The system setting the altitude (uint8_t)
		mode              	: The new altitude in meters (uint32_t)

		'''
		msg = MAVLink_set_altitude_message(target, mode)
		msg.pack(self)
                return msg

	def set_altitude_send(self, target, mode):
		'''
		

		target            	: The system setting the altitude (uint8_t)
		mode              	: The new altitude in meters (uint32_t)

		'''
		return self.send(self.set_altitude_encode(target, mode))

	def request_data_stream_encode(self, target_system, target_component, req_stream_id, req_message_rate, start_stop):
		'''
		

		target_system     	: The target requested to send the message stream. (uint8_t)
		target_component  	: The target requested to send the message stream. (uint8_t)
		req_stream_id     	: The ID of the requested message type (uint8_t)
		req_message_rate  	: The requested interval between two messages of this type (uint16_t)
		start_stop        	: 1 to start sending, 0 to stop sending. (uint8_t)

		'''
		msg = MAVLink_request_data_stream_message(target_system, target_component, req_stream_id, req_message_rate, start_stop)
		msg.pack(self)
                return msg

	def request_data_stream_send(self, target_system, target_component, req_stream_id, req_message_rate, start_stop):
		'''
		

		target_system     	: The target requested to send the message stream. (uint8_t)
		target_component  	: The target requested to send the message stream. (uint8_t)
		req_stream_id     	: The ID of the requested message type (uint8_t)
		req_message_rate  	: The requested interval between two messages of this type (uint16_t)
		start_stop        	: 1 to start sending, 0 to stop sending. (uint8_t)

		'''
		return self.send(self.request_data_stream_encode(target_system, target_component, req_stream_id, req_message_rate, start_stop))

	def request_dynamic_gyro_calibration_encode(self, target_system, target_component, mode, axis, time):
		'''
		

		target_system     	: The system which should auto-calibrate (uint8_t)
		target_component  	: The system component which should auto-calibrate (uint8_t)
		mode              	: The current ground-truth rpm (float)
		axis              	: The axis to calibrate: 0 roll, 1 pitch, 2 yaw (uint8_t)
		time              	: The time to average over in ms (uint16_t)

		'''
		msg = MAVLink_request_dynamic_gyro_calibration_message(target_system, target_component, mode, axis, time)
		msg.pack(self)
                return msg

	def request_dynamic_gyro_calibration_send(self, target_system, target_component, mode, axis, time):
		'''
		

		target_system     	: The system which should auto-calibrate (uint8_t)
		target_component  	: The system component which should auto-calibrate (uint8_t)
		mode              	: The current ground-truth rpm (float)
		axis              	: The axis to calibrate: 0 roll, 1 pitch, 2 yaw (uint8_t)
		time              	: The time to average over in ms (uint16_t)

		'''
		return self.send(self.request_dynamic_gyro_calibration_encode(target_system, target_component, mode, axis, time))

	def request_static_calibration_encode(self, target_system, target_component, time):
		'''
		

		target_system     	: The system which should auto-calibrate (uint8_t)
		target_component  	: The system component which should auto-calibrate (uint8_t)
		time              	: The time to average over in ms (uint16_t)

		'''
		msg = MAVLink_request_static_calibration_message(target_system, target_component, time)
		msg.pack(self)
                return msg

	def request_static_calibration_send(self, target_system, target_component, time):
		'''
		

		target_system     	: The system which should auto-calibrate (uint8_t)
		target_component  	: The system component which should auto-calibrate (uint8_t)
		time              	: The time to average over in ms (uint16_t)

		'''
		return self.send(self.request_static_calibration_encode(target_system, target_component, time))

	def manual_control_encode(self, target, roll, pitch, yaw, thrust, roll_manual, pitch_manual, yaw_manual, thrust_manual):
		'''
		

		target            	: The system to be controlled (uint8_t)
		roll              	: roll (float)
		pitch             	: pitch (float)
		yaw               	: yaw (float)
		thrust            	: thrust (float)
		roll_manual       	: roll control enabled auto:0, manual:1 (uint8_t)
		pitch_manual      	: pitch auto:0, manual:1 (uint8_t)
		yaw_manual        	: yaw auto:0, manual:1 (uint8_t)
		thrust_manual     	: thrust auto:0, manual:1 (uint8_t)

		'''
		msg = MAVLink_manual_control_message(target, roll, pitch, yaw, thrust, roll_manual, pitch_manual, yaw_manual, thrust_manual)
		msg.pack(self)
                return msg

	def manual_control_send(self, target, roll, pitch, yaw, thrust, roll_manual, pitch_manual, yaw_manual, thrust_manual):
		'''
		

		target            	: The system to be controlled (uint8_t)
		roll              	: roll (float)
		pitch             	: pitch (float)
		yaw               	: yaw (float)
		thrust            	: thrust (float)
		roll_manual       	: roll control enabled auto:0, manual:1 (uint8_t)
		pitch_manual      	: pitch auto:0, manual:1 (uint8_t)
		yaw_manual        	: yaw auto:0, manual:1 (uint8_t)
		thrust_manual     	: thrust auto:0, manual:1 (uint8_t)

		'''
		return self.send(self.manual_control_encode(target, roll, pitch, yaw, thrust, roll_manual, pitch_manual, yaw_manual, thrust_manual))

	def debug_vect_encode(self, name, usec, x, y, z):
		'''
		

		name              	: Name (array[10])
		usec              	: Timestamp (uint64_t)
		x                 	: x (float)
		y                 	: y (float)
		z                 	: z (float)

		'''
		msg = MAVLink_debug_vect_message(name, usec, x, y, z)
		msg.pack(self)
                return msg

	def debug_vect_send(self, name, usec, x, y, z):
		'''
		

		name              	: Name (array[10])
		usec              	: Timestamp (uint64_t)
		x                 	: x (float)
		y                 	: y (float)
		z                 	: z (float)

		'''
		return self.send(self.debug_vect_encode(name, usec, x, y, z))

	def gps_local_origin_set_encode(self, latitude, longitude, altitude):
		'''
		Once the MAV sets a new GPS-Local correspondence, this message
		announces

		latitude          	: Latitude (WGS84), expressed as * 1E7 (int32_t)
		longitude         	: Longitude (WGS84), expressed as * 1E7 (int32_t)
		altitude          	: Altitude(WGS84), expressed as * 1000 (int32_t)

		'''
		msg = MAVLink_gps_local_origin_set_message(latitude, longitude, altitude)
		msg.pack(self)
                return msg

	def gps_local_origin_set_send(self, latitude, longitude, altitude):
		'''
		Once the MAV sets a new GPS-Local correspondence, this message
		announces

		latitude          	: Latitude (WGS84), expressed as * 1E7 (int32_t)
		longitude         	: Longitude (WGS84), expressed as * 1E7 (int32_t)
		altitude          	: Altitude(WGS84), expressed as * 1000 (int32_t)

		'''
		return self.send(self.gps_local_origin_set_encode(latitude, longitude, altitude))

	def airspeed_encode(self, airspeed):
		'''
		The calculated airspeed

		airspeed          	: meters/second (float)

		'''
		msg = MAVLink_airspeed_message(airspeed)
		msg.pack(self)
                return msg

	def airspeed_send(self, airspeed):
		'''
		The calculated airspeed

		airspeed          	: meters/second (float)

		'''
		return self.send(self.airspeed_encode(airspeed))

	def global_position_int_encode(self, lat, lon, alt, vx, vy, vz):
		'''
		The filtered global position (e.g. fused GPS and accelerometers). The
		position is in GPS-frame (right-handed, Z-up)

		lat               	: Latitude / X Position, expressed as * 1E7 (int32_t)
		lon               	: Longitude / Y Position, expressed as * 1E7 (int32_t)
		alt               	: Altitude / negative Z Position, expressed as * 1000 (int32_t)
		vx                	: Ground X Speed, expressed as m/s * 100 (int16_t)
		vy                	: Ground Y Speed, expressed as m/s * 100 (int16_t)
		vz                	: Ground Z Speed, expressed as m/s * 100 (int16_t)

		'''
		msg = MAVLink_global_position_int_message(lat, lon, alt, vx, vy, vz)
		msg.pack(self)
                return msg

	def global_position_int_send(self, lat, lon, alt, vx, vy, vz):
		'''
		The filtered global position (e.g. fused GPS and accelerometers). The
		position is in GPS-frame (right-handed, Z-up)

		lat               	: Latitude / X Position, expressed as * 1E7 (int32_t)
		lon               	: Longitude / Y Position, expressed as * 1E7 (int32_t)
		alt               	: Altitude / negative Z Position, expressed as * 1000 (int32_t)
		vx                	: Ground X Speed, expressed as m/s * 100 (int16_t)
		vy                	: Ground Y Speed, expressed as m/s * 100 (int16_t)
		vz                	: Ground Z Speed, expressed as m/s * 100 (int16_t)

		'''
		return self.send(self.global_position_int_encode(lat, lon, alt, vx, vy, vz))

	def named_value_float_encode(self, name, value):
		'''
		Send a key-value pair as float. The use of this message is discouraged
		for normal packets, but a quite efficient way for testing new
		messages and getting experimental debug output.

		name              	: Name of the debug variable (int8_t[10])
		value             	: Floating point value (float)

		'''
		msg = MAVLink_named_value_float_message(name, value)
		msg.pack(self)
                return msg

	def named_value_float_send(self, name, value):
		'''
		Send a key-value pair as float. The use of this message is discouraged
		for normal packets, but a quite efficient way for testing new
		messages and getting experimental debug output.

		name              	: Name of the debug variable (int8_t[10])
		value             	: Floating point value (float)

		'''
		return self.send(self.named_value_float_encode(name, value))

	def named_value_int_encode(self, name, value):
		'''
		Send a key-value pair as integer. The use of this message is
		discouraged for normal packets, but a quite efficient way for
		testing new messages and getting experimental debug output.

		name              	: Name of the debug variable (int8_t[10])
		value             	: Signed integer value (int32_t)

		'''
		msg = MAVLink_named_value_int_message(name, value)
		msg.pack(self)
                return msg

	def named_value_int_send(self, name, value):
		'''
		Send a key-value pair as integer. The use of this message is
		discouraged for normal packets, but a quite efficient way for
		testing new messages and getting experimental debug output.

		name              	: Name of the debug variable (int8_t[10])
		value             	: Signed integer value (int32_t)

		'''
		return self.send(self.named_value_int_encode(name, value))

	def statustext_encode(self, severity, text):
		'''
		Status text message. These messages are printed in yellow in the COMM
		console of QGroundControl. WARNING: They consume quite some
		bandwidth, so use only for important status and error messages. If
		implemented wisely, these messages are buffered on the MCU and sent
		only at a limited rate (e.g. 10 Hz).

		severity          	: Severity of status, 0 = info message, 255 = critical fault (uint8_t)
		text              	: Status text message, without null termination character (array[50])

		'''
		msg = MAVLink_statustext_message(severity, text)
		msg.pack(self)
                return msg

	def statustext_send(self, severity, text):
		'''
		Status text message. These messages are printed in yellow in the COMM
		console of QGroundControl. WARNING: They consume quite some
		bandwidth, so use only for important status and error messages. If
		implemented wisely, these messages are buffered on the MCU and sent
		only at a limited rate (e.g. 10 Hz).

		severity          	: Severity of status, 0 = info message, 255 = critical fault (uint8_t)
		text              	: Status text message, without null termination character (array[50])

		'''
		return self.send(self.statustext_encode(severity, text))

	def debug_encode(self, ind, value):
		'''
		Send a debug value. The index is used to discriminate between values.
		These values show up in the plot of QGroundControl as DEBUG N.

		ind               	: index of debug variable (uint8_t)
		value             	: DEBUG value (float)

		'''
		msg = MAVLink_debug_message(ind, value)
		msg.pack(self)
                return msg

	def debug_send(self, ind, value):
		'''
		Send a debug value. The index is used to discriminate between values.
		These values show up in the plot of QGroundControl as DEBUG N.

		ind               	: index of debug variable (uint8_t)
		value             	: DEBUG value (float)

		'''
		return self.send(self.debug_encode(ind, value))
